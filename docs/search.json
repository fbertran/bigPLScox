[{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-benchmarking.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Benchmarking bigPLScox","text":"High-dimensional survival datasets can computationally demanding. bigPLScox implements algorithms scale large numbers predictors observations via component-based models, sparse penalties, stochastic gradient descent routines. vignette demonstrates benchmark package baseline approaches. recommend using bench package reproducible comparisons.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-benchmarking.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarking bigPLScox","text":"benchmarking dataset simulated dataCox() helper. work moderately sized problem , larger values n p can used stress test performance. compare coxgpls() Cox model available survival.","code":"library(bigPLScox) library(survival) library(bench) set.seed(2024) sim_design <- dataCox(   n = 2000,   lambda = 2,   rho = 1.5,   x = matrix(rnorm(2000 * 50), ncol = 50),   beta = c(1, 3, rep(0, 48)),   cens.rate = 5 ) cox_data <- list(   x = as.matrix(sim_design[,-(1:3)]),   time = sim_design$time,   status = sim_design$status )"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-benchmarking.html","id":"running-the-benchmark","dir":"Articles","previous_headings":"","what":"Running the benchmark","title":"Benchmarking bigPLScox","text":"resulting tibble reports elapsed time, memory allocations, garbage collection statistics estimator.","code":"res <- bench::mark(   bigPLScox = coxgpls(     cox_data$x,     cox_data$time,     cox_data$status,     ncomp = 5,     ind.block.x = c(3, 10)   ),   survival = coxph(Surv(cox_data$time, cox_data$status) ~ cox_data$x, ties = \"breslow\"),   iterations = 5,   check = FALSE ) #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled. res #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 bigPLScox      20ms   21.1ms      22.7    67.3MB     22.7 #> 2 survival     27.9ms   31.2ms      18.9    13.4MB     11.4"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-benchmarking.html","id":"visualising-the-results","dir":"Articles","previous_headings":"","what":"Visualising the results","title":"Benchmarking bigPLScox","text":"plot highlights trade-runtime memory usage. many cases, coxgpls() provides favourable compromise thanks lower latent dimensionality introduced PLS components.","code":"plot(res)"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-benchmarking.html","id":"exporting-benchmark-results","dir":"Articles","previous_headings":"","what":"Exporting benchmark results","title":"Benchmarking bigPLScox","text":"Use function write.csv(res, file = \"benchmarks/bigPLScox-benchmark.csv\") store results part reproducible pipeline. large-scale studies, can wrap benchmark custom loops vary number components, sparsity constraints, data size.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Overview of bigPLScox","text":"goal bigPLScox provide tools fitting partial least squares (PLS) variants Cox proportional hazards model high dimensional survival settings. package implements several algorithms tailored large-scale problems, including sparse, grouped, deviance-residual based approaches. vignette gives quick tour core workflows available package. highlights prepare data, fit model, assess model quality, extract interpretations fitted objects.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"available-algorithms","dir":"Articles","previous_headings":"","what":"Available algorithms","title":"Overview of bigPLScox","text":"following modeling functions provided: coxgpls() generalized PLS Cox regression. coxsgpls() coxspls_sgpls() sparse structured sparse extensions. coxgplsDR() coxsgplsDR() deviance-residual-based estimation. cv.coxgpls() related cv.* helpers component selection. stochastic gradient descent large data package includes big_pls_cox() big_pls_cox_gd().","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"loading-an-example-dataset","dir":"Articles","previous_headings":"","what":"Loading an example dataset","title":"Overview of bigPLScox","text":"dataset contains censored survival information together large number predictors. split training test sets demonstration.","code":"library(bigPLScox) data(micro.censure) data(Xmicro.censure_compl_imp) train_idx <- seq_len(80) Y_train <- micro.censure$survyear[train_idx] C_train <- micro.censure$DC[train_idx] X_train <- Xmicro.censure_compl_imp[train_idx, -40]"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"fitting-a-pls-cox-model","dir":"Articles","previous_headings":"","what":"Fitting a PLS-Cox model","title":"Overview of bigPLScox","text":"coxgpls() provides familiar interface fitting models either via formulas explicit matrices. summary shows selected number components, log-likelihoods, convergence information. ease integration modeling workflows, resulting object provides predicted linear predictors, estimated coefficients, access latent scores.","code":"fit <- coxgpls(X_train, Y_train, C_train, ncomp = 6, ind.block.x = c(3, 10, 15)) fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>          coef exp(coef) se(coef)      z       p #> dim.1 -0.6003    0.5486   0.2197 -2.733 0.00628 #> dim.2 -0.6876    0.5028   0.2816 -2.442 0.01460 #> dim.3 -0.4922    0.6113   0.2498 -1.971 0.04877 #> dim.4  0.2393    1.2703   0.2861  0.836 0.40292 #> dim.5 -0.3689    0.6915   0.2200 -1.677 0.09359 #> dim.6  0.1570    1.1700   0.2763  0.568 0.56979 #>  #> Likelihood ratio test=23.99  on 6 df, p=0.0005249 #> n= 80, number of events= 17"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"model-assessment","dir":"Articles","previous_headings":"","what":"Model assessment","title":"Overview of bigPLScox","text":"Cross-validation helps decide many components retained. cv.coxgpls() helper runs repeated cross-validation optional parallel support.  resulting object can plotted visualise cross-validated deviance select parsimonious model.","code":"set.seed(123) cv_res <- cv.coxgpls(   list(x = X_train, time = Y_train, status = C_train),   nt = 10,   ind.block.x = c(3, 10, 15) ) #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 1 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 2 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 3 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 4 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 5 cv_res #> $nt #> [1] 10 #>  #> $cv.error10 #>  [1] 0.5000000 0.6013049 0.5183694 0.4226056 0.3860331 0.4071207 0.4252845 #>  [8] 0.4001223 0.4464093 0.4526887 0.4695600 #>  #> $cv.se10 #>  [1] 0.00000000 0.03487588 0.06866706 0.07717020 0.07373734 0.07084802 #>  [7] 0.07707939 0.07247893 0.07317843 0.06341118 0.06252387 #>  #> $folds #> $folds$`1` #>  [1] 31 42 69 75 72 12 66 27 71 55 58 49 11 30 37 22 #>  #> $folds$`2` #>  [1] 79 50 57 68 17 15 64 74 34 13 80 76 61  2 24 35 #>  #> $folds$`3` #>  [1] 51 43  9 62 73 32 41 78 29 18  6 16 44 59 33 48 #>  #> $folds$`4` #>  [1] 14 77 26 19 39 65 10 56  5  1 21 20 46 60  3 47 #>  #> $folds$`5` #>  [1] 67 25  7 36 53 45 23 38  8 40 54 28 52  4 70 63 #>  #>  #> $lambda.min10 #> [1] 1 #>  #> $lambda.1se10 #> [1] 0"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"alternative-estimators","dir":"Articles","previous_headings":"","what":"Alternative estimators","title":"Overview of bigPLScox","text":"deviance residual-based estimator coxgplsDR() provides increased robustness iteratively updating residuals. Sparse variants (coxsgpls(), coxspls_sgpls()) enable feature selection high-dimensional designs, optionally groups ind.block.x argument.","code":"dr_fit <- coxgplsDR(X_train, Y_train, C_train, ncomp = 6, ind.block.x = c(3, 10, 15)) dr_fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>          coef exp(coef) se(coef)     z        p #> dim.1 0.92699   2.52690  0.23301 3.978 6.94e-05 #> dim.2 0.85445   2.35008  0.27352 3.124  0.00178 #> dim.3 0.56308   1.75607  0.29847 1.887  0.05922 #> dim.4 0.49242   1.63627  0.32344 1.522  0.12789 #> dim.5 0.18706   1.20569  0.38769 0.482  0.62946 #> dim.6 0.08581   1.08960  0.31517 0.272  0.78541 #>  #> Likelihood ratio test=51.46  on 6 df, p=2.39e-09 #> n= 80, number of events= 17"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"working-with-big-data","dir":"Articles","previous_headings":"","what":"Working with big data","title":"Overview of bigPLScox","text":"extremely large problems, stochastic gradient descent routines big_pls_cox() big_pls_cox_gd() operate memory-mapped matrices created bigmemory biganalytics ecosystems. Refer package documentation details required data preparation steps.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox-overview.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further reading","title":"Overview of bigPLScox","text":"Use help(package = \"bigPLScox\") view exported functions. package website https://fbertran.github.io/bigPLScox/ hosts reference documentation practical articles.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Getting Started with bigPLScox","text":"bigPLScox package provides Partial Least Squares (PLS) regression tools Cox proportional hazards models designed scale high dimensional survival datasets stored bigmemory matrices. vignette presents concise workflow highlights essential functions pre-processing, modelling, validating survival models partial least squares components.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"installing-the-package","dir":"Articles","previous_headings":"","what":"Installing the package","title":"Getting Started with bigPLScox","text":"","code":"# From CRAN (once released) install.packages(\"bigPLScox\")  # Development version # remotes::install_github(\"fbertran/bigPLScox\")"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"loading-example-data","dir":"Articles","previous_headings":"","what":"Loading example data","title":"Getting Started with bigPLScox","text":"package ships small allelotyping dataset use illustrate workflow. dataset intentionally compact keep vignette fast build still demonstrating high-dimensional setting bigPLScox targets.","code":"library(bigPLScox)  data(micro.censure) data(Xmicro.censure_compl_imp)  Y_train <- micro.censure$survyear[1:80] status_train <- micro.censure$DC[1:80] X_train <- Xmicro.censure_compl_imp[1:80, -40]"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"exploring-deviance-residuals","dir":"Articles","previous_headings":"","what":"Exploring deviance residuals","title":"Getting Started with bigPLScox","text":"computeDR() helper visualises deviance residuals assess potential model misspecification fitting PLS components.","code":"residuals_plot <- computeDR(Y_train, status_train, plot = TRUE) head(residuals_plot) #>          1          2          3          4          5          6  #> -1.4843296 -0.5469540 -0.2314550 -0.3400301 -0.9763372 -0.3866766"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"fitting-a-cox-pls-model","dir":"Articles","previous_headings":"","what":"Fitting a Cox-PLS model","title":"Getting Started with bigPLScox","text":"now fit Cox model six PLS components directly matrix predictors. coxgpls() function operates bigmemory objects, also accepts base R matrices example.","code":"set.seed(123) fit <- coxgpls(   Xplan = X_train,   time = Y_train,   status = status_train,   ncomp = 6,   ind.block.x = c(3, 10, 20) )  fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1 -0.54132   0.58198  0.08749 -6.187 6.12e-10 #> dim.2 -0.39414   0.67426  0.10398 -3.791  0.00015 #> dim.3 -0.30806   0.73487  0.10882 -2.831  0.00464 #> dim.4 -0.30364   0.73813  0.11769 -2.580  0.00988 #> dim.5 -0.11503   0.89134  0.09256 -1.243  0.21398 #> dim.6 -0.09611   0.90837  0.10636 -0.904  0.36621 #>  #> Likelihood ratio test=56.28  on 6 df, p=2.553e-10 #> n= 80, number of events= 80"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"cross-validation","dir":"Articles","previous_headings":"","what":"Cross-validation","title":"Getting Started with bigPLScox","text":"Use cv.coxgpls() select number PLS components cross-validation. result includes recommended component count time-dependent AUC metrics monitor predictive performance.","code":"set.seed(123) cv_results <- cv.coxgpls(   data = list(x = X_train, time = Y_train, status = status_train),   nt = 6,   ind.block.x = c(3, 10, 20), ) #> CV Fold 1 #> CV Fold 2 #> CV Fold 3 #> CV Fold 4 #> CV Fold 5 cv_results$opt_nt #> NULL"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"deviance-residual-solver","dir":"Articles","previous_headings":"","what":"Deviance residual solver","title":"Getting Started with bigPLScox","text":"large problems coxgplsDR() solver often converges faster. interface mirrors coxgpls() switching solvers straightforward.","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]   fit_dr=coxgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15),keepX=rep(4,6))  fit_dr #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>         coef exp(coef) se(coef)     z        p #> dim.1 0.7784    2.1781   0.1987 3.917 8.96e-05 #> dim.2 0.9626    2.6186   0.2982 3.228  0.00125 #> dim.3 0.9110    2.4868   0.4075 2.236  0.02536 #> dim.4 0.9022    2.4650   0.4004 2.253  0.02424 #> dim.5 0.1844    1.2026   0.2664 0.692  0.48865 #> dim.6 0.7448    2.1059   0.4228 1.761  0.07819 #>  #> Likelihood ratio test=54.95  on 6 df, p=4.745e-10 #> n= 80, number of events= 17"},{"path":"https://fbertran.github.io/bigPLScox/articles/bigPLScox.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Getting Started with bigPLScox","text":"Explore inst/benchmarks folder scripts compare runtime available solvers larger simulated datasets. Review package reference documentation articles https://fbertran.github.io/bigPLScox/ advanced modelling strategies, including sparse kernel-based extensions.","code":""},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"loading-the-data","dir":"Articles","previous_headings":"","what":"Loading the data","title":"Getting started with bigPLScox","text":"package also exposes original factor-based design matrix. can retrieve :","code":"library(bigPLScox)  data(micro.censure) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  data(Xmicro.censure_compl_imp) X_train_micro <- apply(   as.matrix(Xmicro.censure_compl_imp),   MARGIN = 2,   FUN = as.numeric )[1:80, ] X_train_micro_df <- data.frame(X_train_micro) X_train_micro_orig <- Xmicro.censure_compl_imp[1:80, ] X_train_micro_orig_df <- data.frame(X_train_micro_orig)"},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"deviance-residuals","dir":"Articles","previous_headings":"","what":"Deviance residuals","title":"Getting started with bigPLScox","text":"computeDR() helper obtains deviance residuals null Cox model. often first diagnostic step fitting PLS model. Setting plot = TRUE produces Kaplan-Meier plot survival function.","code":"dev_res <- computeDR(Y_train_micro, C_train_micro, plot = FALSE) head(dev_res) #>          1          2          3          4          5          6  #> -1.4843296 -0.5469540 -0.2314550 -0.3400301 -0.9763372 -0.3866766"},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"building-cox-pls-models","dir":"Articles","previous_headings":"","what":"Building Cox PLS models","title":"Getting started with bigPLScox","text":"deviance residuals available, can fit Cox PLS models using either formula matrix interface. illustrate formula-based approach produces design matrix part computation.","code":"coxgpls(~ ., Y_train_micro, C_train_micro,         ncomp = 6,         trace = TRUE,         model_matrix = TRUE,         dataXplan = X_train_micro_orig_df,         ind.block.x = c(3, 10, 20))[1:10, 1:6] #>    D18S61 D17S794 D13S173 D20S107 TP53 D9S171 #> 1       0       0       0       0    1      0 #> 2       0       0       1       1    0      0 #> 3       0       0       0       1    0      1 #> 4       1       1       1       1    1      1 #> 5       1       0       0       1    1      1 #> 6       1       0       0       1    0      1 #> 7       1       0       1       0    1      0 #> 8       1       0       1       1    0      1 #> 9       0       0       0       0    0      0 #> 10      0       0       0       1    1      0 cox_gpls_fit <- coxgpls(   X_train_micro,   Y_train_micro,   C_train_micro,   ncomp = 6,   ind.block.x = c(3, 10, 15) ) cox_gpls_fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.5771    0.5615   0.2266 -2.546 0.0109 #> dim.2 -0.6350    0.5299   0.2798 -2.269 0.0233 #> dim.3 -0.5675    0.5670   0.2358 -2.407 0.0161 #> dim.4  0.2900    1.3365   0.2897  1.001 0.3167 #> dim.5 -0.3797    0.6841   0.2272 -1.671 0.0947 #> dim.6  0.2398    1.2710   0.2790  0.860 0.3899 #>  #> Likelihood ratio test=26.12  on 6 df, p=0.0002119 #> n= 80, number of events= 17 cox_gpls_fit_formula <- coxgpls(   ~ X_train_micro,   Y_train_micro,   C_train_micro,   ncomp = 6,   ind.block.x = c(3, 10, 15) ) cox_gpls_fit_formula #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.5771    0.5615   0.2266 -2.546 0.0109 #> dim.2 -0.6350    0.5299   0.2798 -2.269 0.0233 #> dim.3 -0.5675    0.5670   0.2358 -2.407 0.0161 #> dim.4  0.2900    1.3365   0.2897  1.001 0.3167 #> dim.5 -0.3797    0.6841   0.2272 -1.671 0.0947 #> dim.6  0.2398    1.2710   0.2790  0.860 0.3899 #>  #> Likelihood ratio test=26.12  on 6 df, p=0.0002119 #> n= 80, number of events= 17"},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"cross-validation-utilities","dir":"Articles","previous_headings":"","what":"Cross-validation utilities","title":"Getting started with bigPLScox","text":"Repeated cross-validation helps determine appropriate number latent components. helpers bigPLScox accept either matrix list x, time, status components.","code":"set.seed(123456) cv_coxgpls_res <- cv.coxgpls(   list(x = X_train_micro, time = Y_train_micro, status = C_train_micro),   nt = 10,   ind.block.x = c(3, 10, 15) ) #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 1 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 2 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 3 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 4 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 5 cv_coxgpls_res #> $nt #> [1] 10 #>  #> $cv.error10 #>  [1] 0.5000000 0.5225223 0.6037656 0.5639968 0.4858183 0.4838439 0.4789940 #>  [8] 0.5024710 0.5087634 0.5042579 0.5291176 #>  #> $cv.se10 #>  [1] 0.00000000 0.05032449 0.04012942 0.03493106 0.04691672 0.04371911 #>  [7] 0.04422282 0.03840676 0.04679141 0.03907217 0.03902846 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0"},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"deviance-residual-based-models","dir":"Articles","previous_headings":"","what":"Deviance-residual based models","title":"Getting started with bigPLScox","text":"package also provides variants refit model deviance residuals.","code":"cox_gplsDR_fit <- coxgplsDR(   X_train_micro,   Y_train_micro,   C_train_micro,   ncomp = 6,   ind.block.x = c(3, 10, 15) ) cox_gplsDR_fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>         coef exp(coef) se(coef)     z        p #> dim.1 0.7784    2.1781   0.1987 3.917 8.96e-05 #> dim.2 0.9626    2.6186   0.2982 3.228  0.00125 #> dim.3 0.9110    2.4868   0.4075 2.236  0.02536 #> dim.4 0.9022    2.4650   0.4004 2.253  0.02424 #> dim.5 0.1844    1.2026   0.2664 0.692  0.48865 #> dim.6 0.7448    2.1059   0.4228 1.761  0.07819 #>  #> Likelihood ratio test=54.95  on 6 df, p=4.745e-10 #> n= 80, number of events= 17 set.seed(123456) cv_coxgplsDR_res <- cv.coxgplsDR(   list(x = X_train_micro, time = Y_train_micro, status = C_train_micro),   nt = 10,   ind.block.x = c(3, 10, 15) ) #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 1 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 2 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 3 #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 4 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 5 cv_coxgplsDR_res #> $nt #> [1] 10 #>  #> $cv.error10 #>  [1] 0.5000000 0.6786893 0.6913293 0.6485690 0.6656184 0.6591497 0.6733976 #>  [8] 0.6252317 0.6388320 0.6592004 0.6589521 #>  #> $cv.se10 #>  [1] 0.00000000 0.04017423 0.02726346 0.03897730 0.03874068 0.04042522 #>  [7] 0.03952962 0.04645295 0.04782038 0.05168926 0.05259748 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0"},{"path":"https://fbertran.github.io/bigPLScox/articles/getting-started.html","id":"dk-splines-extension","dir":"Articles","previous_headings":"","what":"DK-splines extension","title":"Getting started with bigPLScox","text":"flexible baseline hazards, bigPLScox implements DK-splines augmented models. accept inputs classical PLS Cox fits.  sections explore sparse group-sparse extensions well big-memory workflows. deeper dive massive datasets parallel execution, continue “Big-memory workflows bigPLScox” vignette.","code":"cox_DKsplsDR_fit <- coxDKgplsDR(   X_train_micro,   Y_train_micro,   C_train_micro,   ncomp = 6,   validation = \"CV\",   ind.block.x = c(3, 10, 15),   verbose = FALSE ) cox_DKsplsDR_fit #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKgplsDR) #>  #>            coef exp(coef)  se(coef)     z       p #> dim.1 2.902e+00 1.821e+01 1.112e+00 2.609 0.00909 #> dim.2 8.207e+00 3.667e+03 2.637e+00 3.112 0.00186 #> dim.3 5.660e+00 2.871e+02 1.971e+00 2.872 0.00408 #> dim.4 1.607e+01 9.535e+06 5.250e+00 3.061 0.00221 #> dim.5 3.828e+00 4.596e+01 2.040e+00 1.876 0.06062 #> dim.6 1.067e+01 4.288e+04 4.068e+00 2.622 0.00874 #>  #> Likelihood ratio test=66.76  on 6 df, p=1.88e-12 #> n= 80, number of events= 17 set.seed(123456) cv_coxDKgplsDR_res <- cv.coxDKgplsDR(   list(x = X_train_micro, time = Y_train_micro, status = C_train_micro),   nt = 10,   ind.block.x = c(3, 10, 15) ) #> Kernel :  rbfdot  #> Estimated_sigma  0.01257168 #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> one or more coefficients may be infinite #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> one or more coefficients may be infinite #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 1  #> Kernel :  rbfdot  #> Estimated_sigma  0.01198263 #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> one or more coefficients may be infinite #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 2  #> Kernel :  rbfdot  #> Estimated_sigma  0.01156809 #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 3  #> Kernel :  rbfdot  #> Estimated_sigma  0.01287851 #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 4  #> Kernel :  rbfdot  #> Estimated_sigma  0.01127231 #> Warning in min(diff(ux)): no non-missing arguments to min; returning Inf #> CV Fold 5 cv_coxDKgplsDR_res #> $nt #> [1] 10 #>  #> $cv.error10 #>  [1] 0.5000000 0.6381540 0.6963262 0.6537039 0.6204813 0.6886401 0.6632860 #>  [8] 0.6349883 0.6762113 0.6261072 0.6087014 #>  #> $cv.se10 #>  [1] 0.00000000 0.03036225 0.02912723 0.04020941 0.03577022 0.03542745 #>  [7] 0.03283778 0.04532447 0.03390654 0.02968504 0.03306444 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0"},{"path":"https://fbertran.github.io/bigPLScox/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Frederic Bertrand. Maintainer, author. Myriam Maumy-Bertrand. Author.","code":""},{"path":"https://fbertran.github.io/bigPLScox/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Frederic Bertrand Myriam Maumy-Bertrand (2025). Partial Least Squares Cox Models Big Matrices, R package version 0.5.0. Maumy, M. Bertrand, F. (2023). PLS models extension big data. Conference presentation Joint Statistical Meetings (JSM 2023), Toronto, Ontario, Canada, Aug 5–10, 2023. Maumy, M. Bertrand, F. (2023). bigPLS: Fitting cross-validating PLS-based Cox models censored big data. Poster BioC2023: Bioconductor Annual Conference, Dana-Farber Cancer Institute, Boston, MA, USA, Aug 2–4, 2023. doi:10.7490/f1000research.1119546.1.","code":"@Manual{,   title = {Partial Least Squares for Cox Models with Big Matrices},   author = {Frederic Bertrand and Myriam Maumy-Bertrand},   publisher = {manual},   year = {2025},   note = {R package version 0.5.0},   url = {https://fbertran.github.io/bigPLScox/}, } @Misc{,   title = {PLS models and their extension for big data},   author = {Myriam Maumy and Frédéric Bertrand},   year = {2023},   howpublished = {Conference presentation at the Joint Statistical Meetings (JSM 2023)},   address = {Toronto, Ontario, Canada},   note = {Aug 5–10, 2023}, } @Misc{,   title = {bigPLS: Fitting and cross-validating PLS-based Cox models to censored big data},   author = {Myriam Maumy and Frédéric Bertrand},   year = {2023},   howpublished = {Conference presentation at BioC2023: The Bioconductor Annual Conference},   address = {Dana-Farber Cancer Institute, Boston, MA, USA},   note = {Aug 2–4, 2023},   doi = {10.7490/f1000research.1119546.1},   url = {https://doi.org/10.7490/f1000research.1119546.1}, }"},{"path":[]},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"frédéric-bertrand-and-myriam-maumy-bertrand","dir":"","previous_headings":"","what":"Frédéric Bertrand and Myriam Maumy-Bertrand","title":"Partial Least Squares for Cox Models with Big Matrices","text":"bigPLScox provides Partial Least Squares (PLS) methods tailored Cox proportional hazards models large, high-dimensional feature matrices. package works directly bigmemory objects, enabling native C++ accelerators iterative algorithms run without loading full dataset memory. addition classical coxgpls() solver, package contains accelerated variants, cross-validation helpers, model diagnostics. Generalised PLS Cox regression via coxgpls() support grouped predictors. Sparse structured sparse extensions (coxsgpls(), coxspls_sgpls()). Deviance-residual estimators (coxgplsDR(), coxsgplsDR()) robust fits. Cross-validation helpers (cv.coxgpls(), cv.coxsgpls(), …) select number latent components. Dataset generators, diagnostics computeDR() quick residual exploration. Sparse, group-sparse, stochastic gradient variants able consume file-backed big.matrix objects leveraging foreach parallelism. Interfaces big-memory data big_pls_cox() big_pls_cox_gd(). GPU support available current release; ongoing development focuses improving multi-core CPU back-end instead. Additional articles available vignettes/ directory: Getting started bigPLScox — walkthrough core modelling validation helpers. Big-memory workflows bigPLScox — guidance using bigmemory matrices parallel back-ends. reproducible benchmarking script contrasting big_pls_cox() plsRcox::plsRcox() available inst/benchmarks/. documentation website examples maintained Frédéric Bertrand Myriam Maumy-Bertrand.","code":""},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key features","title":"Partial Least Squares for Cox Models with Big Matrices","text":"Scalable Cox-PLS solvers (coxgpls(), coxgplsDR()) operate big matrices stored disk. Cross-validation tooling select optimal number PLS components time-dependent performance metrics. Model diagnostics deviance residual visualisation computeDR(). Benchmark scripts inst/benchmarks/ quantify runtime trade-offs available solvers. Comprehensive vignette (vignettes/bigPLScox.Rmd) showing complete modelling workflow.","code":""},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Partial Least Squares for Cox Models with Big Matrices","text":"can install released version bigPLScox CRAN : can install development version bigPLScox GitHub :","code":"install.packages(\"bigPLScox\") # install.packages(\"devtools\") devtools::install_github(\"fbertran/bigPLScox\")"},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"learning-materials","dir":"","previous_headings":"","what":"Learning materials","title":"Partial Least Squares for Cox Models with Big Matrices","text":"Browse Getting Started vignette vignette(\"bigPLScox\") worked example. Consult function reference https://fbertran.github.io/bigPLScox/. Run benchmark script inst/benchmarks/benchmark_bigPLScox.R compare solver performance simulated data.","code":""},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Partial Least Squares for Cox Models with Big Matrices","text":"following example demonstrates typical workflow subset allelotyping dataset bundled package. Chunks evaluated default README rendered locally, can toggled knitr::opts_chunk$set(eval = FALSE) faster builds. Visualise deviance residuals assess baseline model fit: plot chunk unnamed-chunk-4 Fit Cox-PLS model six components inspect fit summary: Cross-validate number components re-fit using deviance residual solver comparison: Explore alternative estimators coxgplsDR() deviance-residual fitting coxsgpls() sparse component selection. Refer package reference full list available models helper functions.","code":"library(bigPLScox) data(micro.censure) data(Xmicro.censure_compl_imp) Y_train <- micro.censure$survyear[1:80] status_train <- micro.censure$DC[1:80] X_train <- Xmicro.censure_compl_imp[1:80, ] residuals_overview <- computeDR(Y_train, status_train, plot = TRUE) head(residuals_overview) #>          1          2          3          4          5          6  #> -1.4843296 -0.5469540 -0.2314550 -0.3400301 -0.9763372 -0.3866766 set.seed(123) cox_pls_fit <- coxgpls(   Xplan = X_train,   time = Y_train,   status = status_train,   ncomp = 6,   ind.block.x = c(3, 10, 20) ) #> Error in colMeans(x, na.rm = TRUE): 'x' must be numeric cox_pls_fit #> Error: object 'cox_pls_fit' not found set.seed(123) cv_results <- cv.coxgpls(   dataY = list(x = X_train, time = Y_train, status = status_train),   nt = 6,   ind.block.x = c(3, 10, 20) ) #> Error in cv.coxgpls(dataY = list(x = X_train, time = Y_train, status = status_train), : argument \"data\" is missing, with no default cv_results$opt_nt #> NULL cox_pls_dr <- coxgplsDR(   Xplan = X_train,   time = Y_train,   status = status_train,   ncomp = cv_results$opt_nt,   ind.block.x = c(3, 10, 20) ) #> Error in colMeans(x, na.rm = TRUE): 'x' must be numeric cox_pls_dr #> Error: object 'cox_pls_dr' not found"},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"benchmarking","dir":"","previous_headings":"","what":"Benchmarking","title":"Partial Least Squares for Cox Models with Big Matrices","text":"provide reproducible benchmarks compare coxgpls() classical Cox regression implemented survival. Run benchmarking vignette execute script generate timing summaries: large-scale benchmarking, execute scripts inst/benchmarks/ installing optional dependencies listed Suggests DESCRIPTION file. Results stored inst/benchmarks/results/ timestamps traceability.","code":"Rscript inst/benchmarks/cox-benchmark.R Rscript inst/benchmarks/cox_pls_benchmark.R Rscript inst/benchmarks/benchmark_bigPLScox.R"},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"vignettes-and-documentation","dir":"","previous_headings":"","what":"Vignettes and documentation","title":"Partial Least Squares for Cox Models with Big Matrices","text":"Two vignettes ship package: Getting started bigPLScox – end--end introduction covering data preparation, fitting, validation workflows. Benchmarking bigPLScox – guidance evaluating performance baseline Cox implementations using bench package. full reference documentation pkgdown website available https://fbertran.github.io/bigPLScox/.","code":""},{"path":"https://fbertran.github.io/bigPLScox/index.html","id":"bug-reports-and-feature-requests","dir":"","previous_headings":"","what":"Bug reports and feature requests","title":"Partial Least Squares for Cox Models with Big Matrices","text":"Bug reports feature requests can filed issue tracker. Please make sure new code comes unit tests reproducible examples applicable.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/Xmicro.censure_compl_imp.html","id":null,"dir":"Reference","previous_headings":"","what":"Imputed Microsat features — Xmicro.censure_compl_imp","title":"Imputed Microsat features — Xmicro.censure_compl_imp","text":"dataset provides imputed microsat specifications. Imputations computed using Multivariate Imputation Chained Equations (MICE) using predictive mean matching numeric columns, logistic regression imputation binary data factors 2 levels polytomous regression imputation categorical data .e. factors three levels.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/Xmicro.censure_compl_imp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Imputed Microsat features — Xmicro.censure_compl_imp","text":"data frame 117 observations following 40 variables. D18S61 numeric vector D17S794 numeric vector D13S173 numeric vector D20S107 numeric vector TP53 numeric vector D9S171 numeric vector D8S264 numeric vector D5S346 numeric vector D22S928 numeric vector D18S53 numeric vector D1S225 numeric vector D3S1282 numeric vector D15S127 numeric vector D1S305 numeric vector D1S207 numeric vector D2S138 numeric vector D16S422 numeric vector D9S179 numeric vector D10S191 numeric vector D4S394 numeric vector D1S197 numeric vector D6S264 numeric vector D14S65 numeric vector D17S790 numeric vector D5S430 numeric vector D3S1283 numeric vector D4S414 numeric vector D8S283 numeric vector D11S916 numeric vector D2S159 numeric vector D16S408 numeric vector D6S275 numeric vector D10S192 numeric vector sexe numeric vector Agediag numeric vector Siege numeric vector T numeric vector N numeric vector M numeric vector STADE factor levels 0 1 2 3 4","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/Xmicro.censure_compl_imp.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Imputed Microsat features — Xmicro.censure_compl_imp","text":"Allelotyping identification genomic alterations rectal chromosomally unstable tumors without preoperative treatment, Benoît Romain, Agnès Neuville, Nicolas Meyer, Cécile Brigand, Serge Rohr, Anne Schneider, Marie-Pierre Gaub Dominique Guenot, BMC Cancer 2010, 10:561, doi:10.1186/1471-2407-10-561.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/Xmicro.censure_compl_imp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Imputed Microsat features — Xmicro.censure_compl_imp","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/Xmicro.censure_compl_imp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Imputed Microsat features — Xmicro.censure_compl_imp","text":"","code":"# \\donttest{ data(Xmicro.censure_compl_imp) X_train_micro <- Xmicro.censure_compl_imp[1:80,] X_test_micro <- Xmicro.censure_compl_imp[81:117,] rm(X_train_micro,X_test_micro) # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLS-package.html","id":null,"dir":"Reference","previous_headings":"","what":"bigPLScox-package — bigPLScox-package","title":"bigPLScox-package — bigPLScox-package","text":"Provides Partial least squares Regression regular, generalized linear Cox models big data. allows missing data explanatory variables. Repeated k-fold cross-validation models using various criteria. Bootstrap confidence intervals constructions also available.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLS-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bigPLScox-package — bigPLScox-package","text":"TODO","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLS-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bigPLScox-package — bigPLScox-package","text":"Maintainer: Frederic Bertrand frederic.bertrand@lecnam.net (ORCID) Authors: Myriam Maumy-Bertrand myriam.maumy@ehesp.fr (ORCID)","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLS-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bigPLScox-package — bigPLScox-package","text":"","code":"set.seed(314) library(bigPLScox) data(sim_data) head(sim_data) #>                    status         X1         X2         X3        X4         X5 #> 0.0013236229370777      1  0.5448667 -0.9205711  1.1017160 1.3558567  1.4346174 #> 0.193665925040523       1 -0.5641483  0.2733279  0.9731780 1.1232252  0.2652977 #> 0.0167866701431944      1  1.4921118  0.2598002 -1.5436997 0.1165158  1.2208183 #> 0.0584127055299712      1 -0.6430141 -0.9807448 -1.2294945 0.8006227  1.5492078 #> 0.732960708716205       1  0.1876928 -1.2571263  0.9016827 1.3562191 -1.6809553 #> 0.508483386474255       0 -0.6141516 -0.8162560  0.2633415 0.4188066  0.2791399 #>                            X6         X7         X8          X9        X10 #> 0.0013236229370777 -0.8727406  1.5161252  0.7801527 -0.53617252 -0.6990319 #> 0.193665925040523   1.5046047  0.9096495 -1.2200395 -1.57280359  0.8347194 #> 0.0167866701431944 -0.6451659  1.2515692  0.5867273 -0.20080821  0.7492891 #> 0.0584127055299712  1.2557210  0.6188920  0.7123894 -0.67379538 -1.2377412 #> 0.732960708716205   0.7304366 -1.1223302  0.9633307  0.14016470 -0.9996676 #> 0.508483386474255  -0.0538974 -0.1410697 -0.8637916  0.01669784  1.5589135"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLScox-package.html","id":null,"dir":"Reference","previous_headings":"","what":"bigPLScox-package — bigPLScox-package","title":"bigPLScox-package — bigPLScox-package","text":"Provides Partial least squares Regression regular, generalized linear Cox models big data. allows missing data explanatory variables. Repeated k-fold cross-validation models using various criteria. Bootstrap confidence intervals constructions also available.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLScox-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bigPLScox-package — bigPLScox-package","text":"Maumy, M., Bertrand, F. (2023). PLS models extension big data. Joint Statistical Meetings (JSM 2023), Toronto, , Canada. Maumy, M., Bertrand, F. (2023). bigPLS: Fitting cross-validating PLS-based Cox models censored big data. BioC2023 — Bioconductor Annual Conference, Dana-Farber Cancer Institute, Boston, MA, USA. Poster. https://doi.org/10.7490/f1000research.1119546.1 Bastien, P., Bertrand, F., Meyer, N., Maumy-Bertrand, M. (2015). Deviance residuals-based sparse PLS sparse kernel PLS binary classification survival analysis. BMC Bioinformatics, 16, 211.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLScox-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bigPLScox-package — bigPLScox-package","text":"Maintainer: Frederic Bertrand frederic.bertrand@lecnam.net (ORCID) Authors: Myriam Maumy-Bertrand myriam.maumy@ehesp.fr (ORCID)","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigPLScox-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bigPLScox-package — bigPLScox-package","text":"","code":"set.seed(314) library(bigPLScox) data(sim_data) head(sim_data) #>                    status         X1         X2         X3        X4         X5 #> 0.0013236229370777      1  0.5448667 -0.9205711  1.1017160 1.3558567  1.4346174 #> 0.193665925040523       1 -0.5641483  0.2733279  0.9731780 1.1232252  0.2652977 #> 0.0167866701431944      1  1.4921118  0.2598002 -1.5436997 0.1165158  1.2208183 #> 0.0584127055299712      1 -0.6430141 -0.9807448 -1.2294945 0.8006227  1.5492078 #> 0.732960708716205       1  0.1876928 -1.2571263  0.9016827 1.3562191 -1.6809553 #> 0.508483386474255       0 -0.6141516 -0.8162560  0.2633415 0.4188066  0.2791399 #>                            X6         X7         X8          X9        X10 #> 0.0013236229370777 -0.8727406  1.5161252  0.7801527 -0.53617252 -0.6990319 #> 0.193665925040523   1.5046047  0.9096495 -1.2200395 -1.57280359  0.8347194 #> 0.0167866701431944 -0.6451659  1.2515692  0.5867273 -0.20080821  0.7492891 #> 0.0584127055299712  1.2557210  0.6188920  0.7123894 -0.67379538 -1.2377412 #> 0.732960708716205   0.7304366 -1.1223302  0.9633307  0.14016470 -0.9996676 #> 0.508483386474255  -0.0538974 -0.1410697 -0.8637916  0.01669784  1.5589135"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigSurvSGD.na.omit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","title":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","text":"Performs stochastic gradient descent optimisation large-scale survival models removing observations missing values.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigSurvSGD.na.omit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","text":"","code":"bigSurvSGD.na.omit(   formula = survival::Surv(time = time, status = status) ~ .,   data,   norm.method = \"standardize\",   features.mean = NULL,   features.sd = NULL,   opt.method = \"AMSGrad\",   beta.init = NULL,   beta.type = \"averaged\",   lr.const = 0.12,   lr.tau = 0.5,   strata.size = 20,   batch.size = 1,   num.epoch = 100,   b1 = 0.9,   b2 = 0.99,   eps = 1e-08,   inference.method = \"plugin\",   num.boot = 1000,   num.epoch.boot = 100,   boot.method = \"SGD\",   lr.const.boot = 0.12,   lr.tau.boot = 0.5,   num.sample.strata = 1000,   sig.level = 0.05,   beta0 = 0,   alpha = NULL,   lambda = NULL,   nlambda = 100,   num.strata.lambda = 10,   lambda.scale = 1,   parallel.flag = FALSE,   num.cores = NULL,   bigmemory.flag = FALSE,   num.rows.chunk = 1e+06,   col.names = NULL,   type = \"float\" )"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigSurvSGD.na.omit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","text":"formula Model formula describing survival outcome set predictors include optimisation. data Input data set connection big-memory backed design matrix contains variables referenced formula. norm.method Normalization strategy applied feature matrix optimisation, example centring standardising columns. features.mean Optional pre-computed column means used normalising features repeated fits can reuse shared statistics. features.sd Optional pre-computed column standard deviations used concert features.mean scaling predictors. opt.method Gradient based optimisation routine employ, vanilla SGD adaptive methods like Adam. beta.init Vector starting values regression coefficients supplied warm-starting optimisation. beta.type Indicator controlling beta.init interpreted, example whether coefficients correspond original normalised scale. lr.const Base learning-rate constant used stochastic gradient descent routine. lr.tau Learning-rate decay horizon damping factor moderates step size schedule. strata.size Number observations drawn per stratum building mini-batches optimisation loop. batch.size Total number observations assembled stochastic gradient batch. num.epoch Number passes training data used optimisation. b1 First exponential moving-average rate used adaptive methods Adam smooth gradients. b2 Second exponential moving-average rate used adaptive methods smooth squared gradients. eps Numerical stabilisation constant added denominators updating adaptive moments. inference.method Inference approach requested fitting, example naive asymptotics bootstrap resampling. num.boot Number bootstrap replicates draw inference.method relies resampling. num.epoch.boot Number optimisation epochs run within bootstrap replicate. boot.method Type bootstrap scheme apply, ordinary stratified resampling. lr.const.boot Learning-rate constant used bootstrap refits. lr.tau.boot Learning-rate decay factor applied bootstrap refits. num.sample.strata Number strata sampled without replacement bootstrap iteration stratified resampling selected. sig.level Significance level used constructing confidence intervals hypothesis tests. beta0 Optional vector coefficients null hypothesis performing hypothesis tests. alpha Elastic-net mixing parameter controlling relative weight \\(\\ell_1\\) \\(\\ell_2\\) regularisation penalties. lambda Sequence regularisation strengths supplied explicitly penalised estimation. nlambda Number automatically generated lambda values grid produced internally. num.strata.lambda Number strata used tuning lambda via cross-validation search procedures. lambda.scale Scale lambda grid generated, example logarithmic linear spacing. parallel.flag Logical flag enabling parallel computation gradients bootstrap replicates. num.cores Number processing cores use parallel execution enabled. bigmemory.flag Logical flag indicating whether intermediate matrices stored using bigmemory backed objects. num.rows.chunk Row chunk size use streaming data -disk matrix representation. col.names Optional character vector column names associated feature matrix. type Type survival model fit, example Cox proportional hazards accelerated failure time variants.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigSurvSGD.na.omit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","text":"fitted model object storing learned coefficients, optimisation metadata, requested inference summaries. coef: Log hazards ratio. inference used, returns vector estimated coefficients: inference used, returns matrix including estimates confidence intervals coefficients. case penalization, resturns matrix columns corresponding lambdas. coef.exp: Exponentiated version coef (hazards ratio). lambda: Returns lambda(s) used penalizarion. alpha: Returns alpha used penalizarion. features.mean: Returns means features, given calculated features.sd: Returns standard deviations features, given calculated.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigSurvSGD.na.omit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Survival Models with Stochastic Gradient Descent — bigSurvSGD.na.omit","text":"","code":"data(micro.censure, package = \"bigPLScox\") surv_data <- stats::na.omit(micro.censure[, c(\"survyear\", \"DC\", \"sexe\", \"Agediag\")]) fit <- bigSurvSGD.na.omit(   survival::Surv(survyear, DC) ~ .,   data = surv_data,   norm.method = \"standardize\",   opt.method = \"adam\",   batch.size = 16,   num.epoch = 2 ) #> Warning: Strata size times batch size is greater than number of observations. #>  This package resizes them to strata size = 20 and batch size = 4"},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"Compute Partial Least Squares (PLS) components tailored Cox proportional hazards models predictors stored big.matrix bigmemory package.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"","code":"big_pls_cox(X, time, status, ncomp = 2L, control = survival::coxph.control())"},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"X numeric matrix bigmemory::big.matrix object containing predictors. time Numeric vector survival times. status Integer (0/1) vector event indicators. ncomp Number latent components compute. control Optional list passed survival::coxph.control.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"list computed scores, loadings, weights, scaling information fitted Cox model returned survival::coxph.fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"function standardises predictor column, iteratively builds latent scores using martingale residuals Cox fits, deflates predictors without materialising full design matrix memory. -memory file-backed bigmemory matrices supported.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partial Least Squares Components for Cox Models with Big Matrices — big_pls_cox","text":"","code":"if (requireNamespace(\"survival\", quietly = TRUE)) {   set.seed(1)   X <- matrix(rnorm(100), nrow = 20)   time <- rexp(20)   status <- rbinom(20, 1, 0.5)   fit <- big_pls_cox(X, time, status, ncomp = 2)   str(fit) } #> List of 6 #>  $ scores  : num [1:20, 1:2] 0.315 0.28 -1.226 1.668 -0.372 ... #>  $ loadings: num [1:5, 1:2] 0.6905 0.0875 0.2379 0.2205 -0.6772 ... #>  $ weights : num [1:5, 1:2] 0.681 0.273 0.248 0.117 -0.622 ... #>  $ center  : num [1:5] 0.19052 -0.00647 0.1388 0.10174 0.11985 #>  $ scale   : num [1:5] 0.913 0.871 0.81 1.05 0.911 #>  $ cox_fit :List of 10 #>   ..$ coefficients     : num [1:2] 0.756 0.247 #>   ..$ var              : num [1:2, 1:2] 0.1286 0.0544 0.0544 0.2571 #>   ..$ loglik           : num [1:2] -18.5 -15.8 #>   ..$ score            : num 4.82 #>   ..$ iter             : int 4 #>   ..$ linear.predictors: num [1:20] 0.0329 0.0502 -0.7536 1.4699 -0.5345 ... #>   ..$ residuals        : Named num [1:20] -0.26 -0.125 -0.504 0.837 0.921 ... #>   .. ..- attr(*, \"names\")= chr [1:20] \"1\" \"2\" \"3\" \"4\" ... #>   ..$ means            : num [1:2] 7.77e-17 -3.33e-17 #>   ..$ method           : chr \"efron\" #>   ..$ class            : chr \"coxph\" #>  - attr(*, \"class\")= chr \"big_pls_cox\""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox_gd.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","title":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","text":"Fits Cox proportional hazards regression model using gradient-descent optimizer implemented C++. function operates directly bigmemory::big.matrix object avoid materialising large design matrices memory.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox_gd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","text":"","code":"big_pls_cox_gd(   X,   time,   status,   ncomp = NULL,   max_iter = 500L,   tol = 1e-06,   learning_rate = 0.01 )"},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox_gd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","text":"X bigmemory::big.matrix containing design matrix (rows observations). time numeric vector follow-times length equal number rows X. status numeric integer vector length time containing event indicators (1 event, 0 censoring). ncomp integer giving number components (columns) use X. Defaults min(5, ncol(X)). max_iter Maximum number gradient-descent iterations (default 500). tol Convergence tolerance Euclidean distance successive coefficient vectors. learning_rate Step size used gradient-descent updates.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox_gd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","text":"list components: coefficients: Estimated Cox regression coefficients latent scores. loglik: Final partial log-likelihood value. iterations: Number gradient-descent iterations performed. converged: Logical flag indicating whether convergence achieved. scores: Matrix latent score vectors (one column per component). loadings: Matrix loading vectors associated component. weights: Matrix PLS weight vectors. center: Column means used centre predictors. scale: Column scales (standard deviations) used standardise predictors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/big_pls_cox_gd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient-Descent Solver for Cox Models on Big Matrices — big_pls_cox_gd","text":"","code":"if (FALSE) { # \\dontrun{ library(bigmemory) set.seed(1) n <- 50 p <- 10 X <- bigmemory::as.big.matrix(matrix(rnorm(n * p), n, p)) time <- rexp(n, rate = 0.1) status <- rbinom(n, 1, 0.7) fit <- big_pls_cox_gd(X, time, status, ncomp = 3, max_iter = 200) } # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigmatrix-operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","title":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","text":"methods extend base matrix multiplication operator (%*%) group generic Arithmetic big.matrix objects can interoperate base R matrices numeric scalars using high-performance routines provided bigalgebra.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigmatrix-operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","text":"","code":"# S4 method for class 'big.matrix,big.matrix' x %*% y  # S4 method for class 'matrix,big.matrix' x %*% y  # S4 method for class 'big.matrix,matrix' x %*% y  # S4 method for class 'big.matrix,big.matrix' Arith(e1, e2)  # S4 method for class 'big.matrix,matrix' Arith(e1, e2)  # S4 method for class 'matrix,big.matrix' Arith(e1, e2)  # S4 method for class 'numeric,big.matrix' Arith(e1, e2)  # S4 method for class 'big.matrix,numeric' Arith(e1, e2)"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigmatrix-operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","text":"x, y Matrix operands supplied either big.matrix instances base R matrices, depending method signature. e1, e2 Numeric operands, may big.matrix objects, base R matrices, numeric scalars depending method signature.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigmatrix-operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","text":"Matrix multiplications dispatch bigalgebra::dgemm(), mixed arithmetic matrices relies bigalgebra::daxpy(), scalar/matrix combinations use bigalgebra::dadd() appropriate.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigmatrix-operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix and arithmetic operations for big.matrix objects — bigmatrix-operations","text":"","code":"if (requireNamespace(\"bigmemory\", quietly = TRUE) &&     requireNamespace(\"bigalgebra\", quietly = TRUE)) {   x <- bigmemory::big.matrix(2, 2, init = 1)   y <- bigmemory::big.matrix(2, 2, init = 2)   x %*% y   x + y   x * 3 } #> An object of class \"big.matrix\" #> Slot \"address\": #> <pointer: 0x118b72d40> #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial least squares Regression generalized linear models — bigplsRcox","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"function implements extension Partial least squares Regression Cox Models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"","code":"bigplsRcox(formula, data, ...)  bigplsRcoxmodel(formula, data, ...)  # Default S3 method bigplsRcoxmodel(   formula = Surv(time = time, status = status) ~ .,   data,   deepcopy_data = TRUE,   scale.X = TRUE,   scale.Y = TRUE,   nt = 2,   type = \"double\",   allres = TRUE,   verbose = TRUE,   backingfile = NULL,   backingpath = NULL,   descriptorfile = NULL,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"... arguments pass plsRmodel.default plsRmodel.formula nt number components extracted type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. verbose details displayed ? Xplan formula matrix eXplanatory variables (training) dataset time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? limQ2set limit value Q2 dataPredictY predictor(s) (testing) dataset pvals.expli individual p-values reported tune model selection ? alpha.pvals.expli level significance predictors pvals.expli=TRUE tol_Xi minimal value Norm2(Xi) \\(\\mathrm{det}(pp' \\times pp)\\) missing value dataX. defaults \\(10^{-12}\\) weights optional vector 'prior weights' used fitting process. NULL numeric vector. subset optional vector specifying subset observations used fitting process. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxDKplsDR called. model_frame TRUE, model frame returned. method method used fitting model. default method \"glm.fit\" uses iteratively reweighted least squares (IWLS). User-supplied fitting functions can supplied either function character string naming function, function takes arguments glm.fit. control list parameters controlling fitting process. glm.fit passed glm.control. sparse coefficients non-significant predictors (<alpha.pvals.expli) set 0 sparseStop component extraction stop significant predictors (<alpha.pvals.expli) found model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"Depends model used fit model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"typical predictor form response ~ terms response (numeric) response vector terms series terms specifies linear predictor response. terms specification form first + second indicates terms first together terms second duplicates removed. specification form first:second indicates set terms obtained taking interactions terms first terms second. specification first*second indicates cross first second. first + second + first:second. terms formula re-ordered main effects come first, followed interactions, second-order, third-order : avoid pass terms object formula. Non-NULL weights can used indicate different observations different dispersions (values weights inversely proportional dispersions); equivalently, elements weights positive integers w_i, response y_i mean w_i unit-weight observations.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"bigplsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigplsRcox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partial least squares Regression generalized linear models — bigplsRcox","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  bigplsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5) #> ____************************************************____ #> Using big matrix without backing and descriptor files #> Error in (function (cond) .Internal(C_tryCatchHelper(addr, 1L, cond)))(structure(list(message = \"argument \\\"data\\\" is missing, with no default\",     call = bigplsRcoxmodel.default(X_train_micro, time = Y_train_micro,         event = C_train_micro, nt = 5)), class = c(\"getvarError\", \"missingArgError\", \"error\", \"condition\"))): error in evaluating the argument 'filename' in selecting a method for function 'read.big.matrix': argument \"data\" is missing, with no default bigplsRcox(~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5) #> ____************************************************____ #> Using big matrix without backing and descriptor files #> Error in (function (cond) .Internal(C_tryCatchHelper(addr, 1L, cond)))(structure(list(message = \"argument \\\"data\\\" is missing, with no default\",     call = bigplsRcoxmodel.default(~X_train_micro, time = Y_train_micro,         event = C_train_micro, nt = 5)), class = c(\"getvarError\", \"missingArgError\", \"error\", \"condition\"))): error in evaluating the argument 'filename' in selecting a method for function 'read.big.matrix': argument \"data\" is missing, with no default  bigplsRcox(Xplan=X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE, alpha.pvals.expli=.15) #> ____************************************************____ #> Using big matrix without backing and descriptor files #> Error in (function (cond) .Internal(C_tryCatchHelper(addr, 1L, cond)))(structure(list(message = \"argument \\\"data\\\" is missing, with no default\",     call = bigplsRcoxmodel.default(Xplan = X_train_micro, time = Y_train_micro,         event = C_train_micro, nt = 5, sparse = TRUE, alpha.pvals.expli = 0.15)), class = c(\"getvarError\", \"missingArgError\", \"error\", \"condition\"))): error in evaluating the argument 'filename' in selecting a method for function 'read.big.matrix': argument \"data\" is missing, with no default bigplsRcox(Xplan=~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE, alpha.pvals.expli=.15) #> ____************************************************____ #> Using big matrix without backing and descriptor files #> Error in (function (cond) .Internal(C_tryCatchHelper(addr, 1L, cond)))(structure(list(message = \"argument \\\"data\\\" is missing, with no default\",     call = bigplsRcoxmodel.default(Xplan = ~X_train_micro, time = Y_train_micro,         event = C_train_micro, nt = 5, sparse = TRUE, alpha.pvals.expli = 0.15)), class = c(\"getvarError\", \"missingArgError\", \"error\", \"condition\"))): error in evaluating the argument 'filename' in selecting a method for function 'read.big.matrix': argument \"data\" is missing, with no default"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigscale.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Scaled Design Matrices for Big Survival Models — bigscale","title":"Construct Scaled Design Matrices for Big Survival Models — bigscale","text":"Prepares large-scale feature matrix stochastic gradient descent byapplying optional normalisation, stratified sampling, batching rules.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigscale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Scaled Design Matrices for Big Survival Models — bigscale","text":"","code":"bigscale(   formula = survival::Surv(time = time, status = status) ~ .,   data,   norm.method = \"standardize\",   strata.size = 20,   batch.size = 1,   features.mean = NULL,   features.sd = NULL,   parallel.flag = FALSE,   num.cores = NULL,   bigmemory.flag = FALSE,   num.rows.chunk = 1e+06,   col.names = NULL,   type = \"short\" )"},{"path":"https://fbertran.github.io/bigPLScox/reference/bigscale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Scaled Design Matrices for Big Survival Models — bigscale","text":"formula formula used extract outcome predictors included scaled design matrix. data Input data source containing variables referenced formula. norm.method Normalisation strategy (example centring standardising columns) applied feature matrix. strata.size Number observations retain stratum constructing stratified batches. batch.size Total size mini-batch produced scaling routine. features.mean Optional vector column means can reused normalise multiple data sets consistent manner. features.sd Optional vector column standard deviations pairs features.mean scaling. parallel.flag Logical flag signalling whether scaling work parallelised across cores. num.cores Number processor cores allocated parallel.flag TRUE. bigmemory.flag Logical flag specifying whether intermediate results stored bigmemory-backed matrices. num.rows.chunk Chunk size used streaming data -disk objects memory. col.names Optional character vector assigning column names generated design matrix. type Type model preprocessing target prepared, survival regression.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/bigscale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Scaled Design Matrices for Big Survival Models — bigscale","text":"scaled design matrix scaler class along metadata describing transformation applied. time.indices: indices time variable cens.indices: indices censored variables features.indices: indices features time.sd: standard deviation time variable time.mean: mean time variable features.sd: standard deviation features features.mean: mean features nr: number rows nc: number columns col.names: columns names","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/bigscale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Scaled Design Matrices for Big Survival Models — bigscale","text":"","code":"data(micro.censure, package = \"bigPLScox\") surv_data <- stats::na.omit(   micro.censure[, c(\"survyear\", \"DC\", \"sexe\", \"Agediag\")] ) scaled <- bigscale(   survival::Surv(survyear, DC) ~ .,   data = surv_data,   norm.method = \"standardize\",   batch.size = 16 ) #> Warning: Strata size times batch size is greater than number of observations. #>  This package resizes them to strata size = 20 and batch size = 4"},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute deviance residuals — computeDR","title":"Compute deviance residuals — computeDR","text":"function computes residuals null model fit using coxph function survival package. Since computation use explanatory variables, likely doable even big dat without dedicated framework.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute deviance residuals — computeDR","text":"","code":"computeDR(   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleY = TRUE,   plot = FALSE )"},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute deviance residuals — computeDR","text":"time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleY time values standardized ? plot survival function plotted ?","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute deviance residuals — computeDR","text":"Residuals null model fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute deviance residuals — computeDR","text":"Bastien, P., Bertrand, F., Meyer, N., Maumy-Bertrand, M. (2015). Deviance residuals-based sparse PLS sparse kernel PLS binary classification survival analysis. BMC Bioinformatics, 16, 211. Therneau, T.M., Grambsch, P.M. (2000). Modeling Survival Data: Extending Cox Model. Springer.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute deviance residuals — computeDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/computeDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute deviance residuals — computeDR","text":"","code":"data(micro.censure, package = \"bigPLScox\")  Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  Y_DR <- computeDR(Y_train_micro,C_train_micro) Y_DR <- computeDR(Y_train_micro,C_train_micro,plot=TRUE)"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"","code":"coxDKgplsDR(Xplan, ...)  # S3 method for class 'formula' coxDKgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )  # Default S3 method coxDKgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors. kernel kernel function used training predicting. parameter can set function, class kernel, computes inner product feature space two vector arguments (see kernels). kernlab package provides popular kernel functions can used setting kernel parameter following strings: list(\"rbfdot\") Radial Basis kernel \"Gaussian\" list(\"polydot\") Polynomial kernel list(\"vanilladot\") Linear kernel list(\"tanhdot\") Hyperbolic tangent kernel list(\"laplacedot\") Laplacian kernel list(\"besseldot\") Bessel kernel list(\"anovadot\") ANOVA RBF kernel list(\"splinedot\") Spline kernel hyperkernel list hyper-parameters (kernel parameters). list contains parameters used kernel function. valid parameters existing kernels : sigma, inverse kernel width Radial Basis kernel function \"rbfdot\" Laplacian kernel \"laplacedot\". degree, scale, offset Polynomial kernel \"polydot\". scale, offset Hyperbolic tangent kernel function \"tanhdot\". sigma, order, degree Bessel kernel \"besseldot\". sigma, degree ANOVA kernel \"anovadot\". case Radial Basis kernel function (Gaussian) Laplacian kernel, hyperkernel missing, heuristics sigest used calculate good sigma value data. verbose details displayed ?","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"allres=FALSE : cox_DKgplsDR Final Cox-model. allres=TRUE : tt_DKgplsDR PLSR components. cox_DKgplsDR Final Cox-model. DKgplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Direct Kernel group PLS model on the (Deviance) Residuals — coxDKgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxDKgplsDR_fit=coxDKgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKgplsDR) #>  #>            coef exp(coef)  se(coef)     z       p #> dim.1 2.882e+00 1.784e+01 1.106e+00 2.606 0.00915 #> dim.2 7.980e+00 2.920e+03 2.570e+00 3.105 0.00190 #> dim.3 5.410e+00 2.236e+02 1.880e+00 2.878 0.00400 #> dim.4 1.559e+01 5.897e+06 5.096e+00 3.059 0.00222 #> dim.5 3.741e+00 4.212e+01 2.015e+00 1.857 0.06336 #> dim.6 1.054e+01 3.768e+04 4.080e+00 2.583 0.00980 #>  #> Likelihood ratio test=65.97  on 6 df, p=2.731e-12 #> n= 80, number of events= 17  (coxDKgplsDR_fit=coxDKgplsDR(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKgplsDR) #>  #>            coef exp(coef)  se(coef)     z       p #> dim.1 2.907e+00 1.830e+01 1.114e+00 2.609 0.00907 #> dim.2 8.249e+00 3.825e+03 2.650e+00 3.113 0.00185 #> dim.3 5.707e+00 3.008e+02 1.988e+00 2.870 0.00410 #> dim.4 1.616e+01 1.040e+07 5.278e+00 3.061 0.00220 #> dim.5 3.844e+00 4.670e+01 2.045e+00 1.880 0.06014 #> dim.6 1.069e+01 4.381e+04 4.066e+00 2.629 0.00857 #>  #> Likelihood ratio test=66.91  on 6 df, p=1.759e-12 #> n= 80, number of events= 17  (coxDKgplsDR_fit=coxDKgplsDR(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKgplsDR) #>  #>            coef exp(coef)  se(coef)     z       p #> dim.1 2.936e+00 1.884e+01 1.123e+00 2.614 0.00895 #> dim.2 8.479e+00 4.814e+03 2.721e+00 3.116 0.00183 #> dim.3 5.962e+00 3.884e+02 2.084e+00 2.860 0.00423 #> dim.4 1.661e+01 1.637e+07 5.428e+00 3.061 0.00221 #> dim.5 3.928e+00 5.082e+01 2.070e+00 1.898 0.05770 #> dim.6 1.079e+01 4.871e+04 4.057e+00 2.660 0.00780 #>  #> Likelihood ratio test=67.65  on 6 df, p=1.24e-12 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_spls_sgpls_fit) #> Warning: object 'cox_spls_sgpls_fit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgplsDR perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"","code":"coxDKsgplsDR(Xplan, ...)  # S3 method for class 'formula' coxDKsgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )  # Default S3 method coxDKsgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. alpha.x mixing parameter (value 0 1) related sparsity within group X dataset. upper.lambda default upper.lambda=10^5. large value specifying upper bound intervall lambda values searching value tuning parameter (lambda) corresponding non-zero group variables. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors. kernel kernel function used training predicting. parameter can set function, class kernel, computes inner product feature space two vector arguments (see kernels). kernlab package provides popular kernel functions can used setting kernel parameter following strings: list(\"rbfdot\") Radial Basis kernel \"Gaussian\" list(\"polydot\") Polynomial kernel list(\"vanilladot\") Linear kernel list(\"tanhdot\") Hyperbolic tangent kernel list(\"laplacedot\") Laplacian kernel list(\"besseldot\") Bessel kernel list(\"anovadot\") ANOVA RBF kernel list(\"splinedot\") Spline kernel hyperkernel list hyper-parameters (kernel parameters). list contains parameters used kernel function. valid parameters existing kernels : sigma, inverse kernel width Radial Basis kernel function \"rbfdot\" Laplacian kernel \"laplacedot\". degree, scale, offset Polynomial kernel \"polydot\". scale, offset Hyperbolic tangent kernel function \"tanhdot\". sigma, order, degree Bessel kernel \"besseldot\". sigma, degree ANOVA kernel \"anovadot\". case Radial Basis kernel function (Gaussian) Laplacian kernel, hyperkernel missing, heuristics sigest used calculate good sigma value data. verbose details displayed ?","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"allres=FALSE : cox_sgplsDR Final Cox-model. allres=TRUE : tt_sgplsDR PLSR components. cox_sgplsDR Final Cox-model. sgplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKsgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Direct Kernel group sparse PLS model on the (Deviance) Residuals — coxDKsgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxDKsgplsDR_fit=coxDKsgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17  (coxDKsgplsDR_fit=coxDKsgplsDR(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17  (coxDKsgplsDR_fit=coxDKsgplsDR(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_sgplsDR_sgfit) #> Warning: object 'cox_sgplsDR_sgfit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"","code":"coxDKspls_sgplsDR(Xplan, ...)  # S3 method for class 'formula' coxDKspls_sgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )  # Default S3 method coxDKspls_sgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   kernel = \"rbfdot\",   hyperkernel,   verbose = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors. kernel kernel function used training predicting. parameter can set function, class kernel, computes inner product feature space two vector arguments (see kernels). kernlab package provides popular kernel functions can used setting kernel parameter following strings: list(\"rbfdot\") Radial Basis kernel \"Gaussian\" list(\"polydot\") Polynomial kernel list(\"vanilladot\") Linear kernel list(\"tanhdot\") Hyperbolic tangent kernel list(\"laplacedot\") Laplacian kernel list(\"besseldot\") Bessel kernel list(\"anovadot\") ANOVA RBF kernel list(\"splinedot\") Spline kernel hyperkernel list hyper-parameters (kernel parameters). list contains parameters used kernel function. valid parameters existing kernels : sigma, inverse kernel width Radial Basis kernel function \"rbfdot\" Laplacian kernel \"laplacedot\". degree, scale, offset Polynomial kernel \"polydot\". scale, offset Hyperbolic tangent kernel function \"tanhdot\". sigma, order, degree Bessel kernel \"besseldot\". sigma, degree ANOVA kernel \"anovadot\". case Radial Basis kernel function (Gaussian) Laplacian kernel, hyperkernel missing, heuristics sigest used calculate good sigma value data. verbose details displayed ? alpha.x numeric vector length ncomp giving sparsity level applied within component. Required ind.block.x specified. upper.lambda numeric value controlling maximal penalty considered sgPLS estimating sparse group loadings. Defaults 10^5.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"allres=FALSE : cox_DKspls_sgplsDR Final Cox-model. allres=TRUE : tt_DKspls_sgplsDR PLSR components. cox_DKspls_sgplsDR Final Cox-model. DKspls_sgplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxDKspls_sgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxDKspls_sgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (cox_DKspls_sgplsDR_fit=coxDKspls_sgplsDR(X_train_micro,Y_train_micro, C_train_micro,ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKspls_sgplsDR) #>  #>            coef exp(coef)  se(coef)     z        p #> dim.1 3.334e+00 2.804e+01 1.238e+00 2.692 0.007095 #> dim.2 9.578e+00 1.444e+04 2.865e+00 3.343 0.000829 #> dim.3 7.886e+00 2.659e+03 2.891e+00 2.728 0.006377 #> dim.4 1.369e+01 8.842e+05 4.470e+00 3.063 0.002188 #> dim.5 4.028e+00 5.615e+01 2.151e+00 1.873 0.061074 #> dim.6 6.562e+00 7.074e+02 2.831e+00 2.318 0.020448 #>  #> Likelihood ratio test=66.14  on 6 df, p=2.526e-12 #> n= 80, number of events= 17  (cox_DKspls_sgplsDR_fit=coxDKspls_sgplsDR(~X_train_micro,Y_train_micro, C_train_micro,ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKspls_sgplsDR) #>  #>            coef exp(coef)  se(coef)     z        p #> dim.1 3.302e+00 2.718e+01 1.232e+00 2.680 0.007352 #> dim.2 9.661e+00 1.570e+04 2.895e+00 3.337 0.000846 #> dim.3 8.212e+00 3.684e+03 2.952e+00 2.782 0.005409 #> dim.4 1.422e+01 1.495e+06 4.648e+00 3.059 0.002220 #> dim.5 4.073e+00 5.873e+01 2.193e+00 1.857 0.063244 #> dim.6 7.077e+00 1.185e+03 2.954e+00 2.395 0.016603 #>  #> Likelihood ratio test=66.48  on 6 df, p=2.15e-12 #> n= 80, number of events= 17  (cox_DKspls_sgplsDR_fit=coxDKspls_sgplsDR(~.,Y_train_micro,C_train_micro, ncomp=6,dataXplan=X_train_micro_df,ind.block.x=c(3,10,15),  alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_DKspls_sgplsDR) #>  #>            coef exp(coef)  se(coef)     z        p #> dim.1 3.300e+00 2.711e+01 1.233e+00 2.676 0.007450 #> dim.2 9.647e+00 1.548e+04 2.885e+00 3.344 0.000825 #> dim.3 8.074e+00 3.209e+03 2.901e+00 2.783 0.005386 #> dim.4 1.414e+01 1.389e+06 4.609e+00 3.069 0.002148 #> dim.5 4.100e+00 6.036e+01 2.188e+00 1.874 0.060979 #> dim.6 7.143e+00 1.266e+03 2.991e+00 2.389 0.016913 #>  #> Likelihood ratio test=66.38  on 6 df, p=2.256e-12 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_DKspls_sgplsDR_fit)"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on group PLSR components — coxgpls","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"","code":"coxgpls(Xplan, ...)  # S3 method for class 'formula' coxgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. missing, every predictor placed group. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"allres=FALSE : cox_gpls Final Cox-model. allres=TRUE : tt_gpls PLSR components. cox_gpls Final Cox-model. gpls_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on group PLSR components — coxgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxgpls_fit=coxgpls(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>            coef exp(coef)  se(coef)      z      p #> dim.1 -0.696933  0.498111  0.307358 -2.267 0.0234 #> dim.2 -0.101947  0.903078  0.250931 -0.406 0.6845 #> dim.3 -0.601144  0.548184  0.269089 -2.234 0.0255 #> dim.4  0.001834  1.001836  0.458089  0.004 0.9968 #> dim.5 -0.276795  0.758210  0.287096 -0.964 0.3350 #> dim.6 -0.785772  0.455768  0.321865 -2.441 0.0146 #>  #> Likelihood ratio test=19.33  on 6 df, p=0.003642 #> n= 80, number of events= 17  (coxgpls_fit=coxgpls(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>            coef exp(coef)  se(coef)      z      p #> dim.1 -0.696933  0.498111  0.307358 -2.267 0.0234 #> dim.2 -0.101947  0.903078  0.250931 -0.406 0.6845 #> dim.3 -0.601144  0.548184  0.269089 -2.234 0.0255 #> dim.4  0.001834  1.001836  0.458089  0.004 0.9968 #> dim.5 -0.276795  0.758210  0.287096 -0.964 0.3350 #> dim.6 -0.785772  0.455768  0.321865 -2.441 0.0146 #>  #> Likelihood ratio test=19.33  on 6 df, p=0.003642 #> n= 80, number of events= 17  (ccoxgpls_fit=coxgpls(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gpls) #>  #>            coef exp(coef)  se(coef)      z      p #> dim.1 -0.696933  0.498111  0.307358 -2.267 0.0234 #> dim.2 -0.101947  0.903078  0.250931 -0.406 0.6845 #> dim.3 -0.601144  0.548184  0.269089 -2.234 0.0255 #> dim.4  0.001834  1.001836  0.458089  0.004 0.9968 #> dim.5 -0.276795  0.758210  0.287096 -0.964 0.3350 #> dim.6 -0.785772  0.455768  0.321865 -2.441 0.0146 #>  #> Likelihood ratio test=19.33  on 6 df, p=0.003642 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_spls_sgpls_fit) #> Warning: object 'cox_spls_sgpls_fit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"","code":"coxgplsDR(Xplan, ...)  # S3 method for class 'formula' coxgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"allres=FALSE : cox_gplsDR Final Cox-model. allres=TRUE : tt_gplsDR PLSR components. cox_gplsDR Final Cox-model. gplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on group PLSR components using the (Deviance) Residuals — coxgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxgplsDR_fit=coxgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>         coef exp(coef) se(coef)     z        p #> dim.1 0.7784    2.1781   0.1987 3.917 8.96e-05 #> dim.2 0.9626    2.6186   0.2982 3.228  0.00125 #> dim.3 0.9110    2.4868   0.4075 2.236  0.02536 #> dim.4 0.9022    2.4650   0.4004 2.253  0.02424 #> dim.5 0.1844    1.2026   0.2664 0.692  0.48865 #> dim.6 0.7448    2.1059   0.4228 1.761  0.07819 #>  #> Likelihood ratio test=54.95  on 6 df, p=4.745e-10 #> n= 80, number of events= 17  (coxgplsDR_fit=coxgplsDR(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>         coef exp(coef) se(coef)     z        p #> dim.1 0.7784    2.1781   0.1987 3.917 8.96e-05 #> dim.2 0.9626    2.6186   0.2982 3.228  0.00125 #> dim.3 0.9110    2.4868   0.4075 2.236  0.02536 #> dim.4 0.9022    2.4650   0.4004 2.253  0.02424 #> dim.5 0.1844    1.2026   0.2664 0.692  0.48865 #> dim.6 0.7448    2.1059   0.4228 1.761  0.07819 #>  #> Likelihood ratio test=54.95  on 6 df, p=4.745e-10 #> n= 80, number of events= 17  (coxgplsDR_fit=coxgplsDR(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15),keepX=rep(4,6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_gplsDR) #>  #>         coef exp(coef) se(coef)     z        p #> dim.1 0.7784    2.1781   0.1987 3.917 8.96e-05 #> dim.2 0.9626    2.6186   0.2982 3.228  0.00125 #> dim.3 0.9110    2.4868   0.4075 2.236  0.02536 #> dim.4 0.9022    2.4650   0.4004 2.253  0.02424 #> dim.5 0.1844    1.2026   0.2664 0.692  0.48865 #> dim.6 0.7448    2.1059   0.4228 1.761  0.07819 #>  #> Likelihood ratio test=54.95  on 6 df, p=4.745e-10 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_spls_sgpls_fit) #> Warning: object 'cox_spls_sgpls_fit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"","code":"coxsgpls(Xplan, ...)  # S3 method for class 'formula' coxsgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxsgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. alpha.x mixing parameter (value 0 1) related sparsity within group X dataset. upper.lambda default upper.lambda=10^5. large value specifying upper bound intervall lambda values searching value tuning parameter (lambda) corresponding non-zero group variables. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"allres=FALSE : cox_sgpls Final Cox-model. allres=TRUE : tt_sgpls PLSR components. cox_sgpls Final Cox-model. sgpls_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on group sparse PLSR components — coxsgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxsgpls_fit=coxsgpls(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (coxsgpls_fit=coxsgpls(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (coxsgpls_fit=coxsgpls(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_sgpls_sgfit) #> Warning: object 'cox_sgpls_sgfit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgplsDR perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"","code":"coxsgplsDR(Xplan, ...)  # S3 method for class 'formula' coxsgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxsgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   modepls = \"regression\",   ind.block.x,   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. alpha.x mixing parameter (value 0 1) related sparsity within group X dataset. upper.lambda default upper.lambda=10^5. large value specifying upper bound intervall lambda values searching value tuning parameter (lambda) corresponding non-zero group variables. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"allres=FALSE : cox_sgplsDR Final Cox-model. allres=TRUE : tt_sgplsDR PLSR components. cox_sgplsDR Final Cox-model. sgplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxsgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on group sparse PLSR components using the (Deviance) Residuals — coxsgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)),FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (coxsgplsDR_fit=coxsgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17  (coxsgplsDR_fit=coxsgplsDR(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17  (coxsgplsDR_fit=coxsgplsDR(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_sgplsDR) #>  #>           coef exp(coef) se(coef)      z        p #> dim.1  0.85431   2.34976  0.24239  3.525 0.000424 #> dim.2  0.96004   2.61180  0.29938  3.207 0.001342 #> dim.3  1.64702   5.19149  0.69268  2.378 0.017419 #> dim.4  0.23137   1.26033  0.23656  0.978 0.328037 #> dim.5 -0.06767   0.93457  0.30587 -0.221 0.824917 #> dim.6  0.37661   1.45734  0.36468  1.033 0.301734 #>  #> Likelihood ratio test=53.66  on 6 df, p=8.658e-10 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_sgplsDR_sgfit) #> Warning: object 'cox_sgplsDR_sgfit' not found"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"","code":"coxspls_sgpls(Xplan, ...)  # S3 method for class 'formula' coxspls_sgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxspls_sgpls(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors. alpha.x numeric vector length ncomp giving sparsity level applied within component. Required ind.block.x specified. upper.lambda numeric value controlling maximal penalty considered sgPLS estimating sparse group loadings. Defaults 10^5.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"allres=FALSE : cox_spls_sgpls Final Cox-model. allres=TRUE : tt_spls_sgpls PLSR components. cox_spls_sgpls Final Cox-model. spls_sgpls_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on sparse PLSR components — coxspls_sgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (cox_spls_sgpls_fit=coxspls_sgpls(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (cox_spls_sgpls_fit=coxspls_sgpls(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (cox_spls_sgpls_fit=coxspls_sgpls(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgpls) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_spls_sgpls_fit)"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"function computes Cox Model based PLSR components computed model explanatory variables: Xplan. uses package sgPLS perform group PLSR fit.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"","code":"coxspls_sgplsDR(Xplan, ...)  # S3 method for class 'formula' coxspls_sgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   dataXplan = NULL,   subset,   weights,   model_frame = FALSE,   model_matrix = FALSE,   contrasts.arg = NULL,   ... )  # Default S3 method coxspls_sgplsDR(   Xplan,   time,   time2,   event,   type,   origin,   typeres = \"deviance\",   collapse,   weighted,   scaleX = TRUE,   scaleY = TRUE,   ncomp = min(7, ncol(Xplan)),   ind.block.x = NULL,   modepls = \"regression\",   keepX,   alpha.x,   upper.lambda = 10^5,   plot = FALSE,   allres = FALSE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"Xplan formula matrix eXplanatory variables (training) dataset ... Arguments passed survival::coxph. time right censored data, follow time. interval data, first argument starting time interval. time2 status indicator, normally 0=alive, 1=dead. choices TRUE/FALSE (TRUE = death) 1/2 (2=death). interval censored data, status indicator 0=right censored, 1=event time, 2=left censored, 3=interval censored. Although unusual, event indicator can omitted, case subjects assumed event. event ending time interval interval censored counting process data . Intervals assumed open left closed right, (start, end]. counting process data, event indicates whether event occurred end interval. type character string specifying type censoring. Possible values \"right\", \"left\", \"counting\", \"interval\", \"interval2\". default \"right\" \"counting\" depending whether time2 argument absent present, respectively. origin counting process data, hazard function origin. option intended used conjunction model containing time dependent strata order align subjects properly cross one strata another, rarely proven useful. typeres character string indicating type residual desired. Possible values \"martingale\", \"deviance\", \"score\", \"schoenfeld\", \"dfbeta\", \"dfbetas\", \"scaledsch\". enough string determine unique match required. collapse vector indicating rows collapse (sum) . time-dependent models one row data can pertain single individual. 4 individuals represented 3, 1, 2 4 rows data respectively, collapse=c(1,1,1,2,3,3,4,4,4,4) used obtain per subject rather per observation residuals. weighted TRUE model fit case weights, weighted residuals returned. scaleX Xplan columns standardized ? scaleY time values standardized ? ncomp number components include model. supplied, min(7,maximal number) components used. ind.block.x vector integers describing grouping X-variables. ind.block.x <- c(3,10,15) means X structured 4 groups: X1 X3; X4 X10, X11 X15 X16 Xp p number variables X matrix. modepls character string. type algorithm use, (partially) matching one \"regression\", \"canonical\". See gPLS details keepX numeric vector length ncomp, number variables keep X-loadings. default variables kept model. alpha.x numeric vector length ncomp giving sparsity level applied within component. Required ind.block.x specified. upper.lambda numeric value giving upper bound regularized regression penalty used sgPLS. Defaults 10\\(^5\\). plot survival function plotted ?) allres FALSE return Cox model TRUE additionnal results. See details. Defaults FALSE. dataXplan optional data frame, list environment (object coercible .data.frame data frame) containing variables model. found dataXplan, variables taken environment(Xplan), typically environment coxpls called. subset optional vector specifying subset observations used fitting process. weights optional vector 'prior weights' used fitting process. NULL numeric vector. model_frame TRUE, model frame returned. model_matrix TRUE, model matrix returned. contrasts.arg list, whose entries values (numeric matrices, functions character strings naming functions) used replacement values contrasts replacement function whose names names columns data containing factors.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"allres=FALSE : cox_spls_sgplsDR Final Cox-model. allres=TRUE : tt_spls_sgplsDR PLSR components. cox_spls_sgplsDR Final Cox-model. spls_sgplsDR_mod PLSR model.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"allres=FALSE returns final Cox-model. allres=TRUE returns list PLS components, final Cox-model group PLSR model. allres=TRUE useful evluating model prediction accuracy test sample.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"group Sparse Group Partial Least Square approach applied Genomics context, Liquet Benoit, Lafaye de Micheaux, Boris Hejblum, Rodolphe Thiebaut (2016). Bioinformatics. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/coxspls_sgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting a Cox-Model on sparse PLSR components using the (Deviance) Residuals — coxspls_sgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp)  X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  (cox_spls_sgplsDR_fit=coxspls_sgplsDR(X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgplsDR) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (cox_spls_sgplsDR_fit=coxspls_sgplsDR(~X_train_micro,Y_train_micro,C_train_micro, ncomp=6,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgplsDR) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17  (cox_spls_sgplsDR_fit=coxspls_sgplsDR(~.,Y_train_micro,C_train_micro,ncomp=6, dataXplan=X_train_micro_df,ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6))) #> Call: #> coxph(formula = YCsurv ~ ., data = tt_spls_sgplsDR) #>  #>          coef exp(coef) se(coef)      z      p #> dim.1 -0.7429    0.4757   0.2647 -2.807 0.0050 #> dim.2 -0.4003    0.6701   0.2622 -1.527 0.1268 #> dim.3 -0.6329    0.5310   0.2930 -2.160 0.0308 #> dim.4 -0.5733    0.5637   0.2591 -2.213 0.0269 #> dim.5  0.1578    1.1709   0.2375  0.664 0.5064 #> dim.6 -0.2209    0.8018   0.3337 -0.662 0.5079 #>  #> Likelihood ratio test=21.77  on 6 df, p=0.001331 #> n= 80, number of events= 17   rm(X_train_micro,Y_train_micro,C_train_micro,cox_spls_sgplsDR_fit)"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"function cross-validates coxDKgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"","code":"cv.coxDKgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"data list three items: x explanatory variables passed coxDKgplsDR's Xplan argument, time passed coxDKgplsDR's time argument, status coxDKgplsDR's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxDKgplsDR.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Direct Kernel group PLS model fitted on the (Deviance) Residuals — cv.coxDKgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxDKgplsDR.res=cv.coxDKgplsDR(list(x=X_train_micro,time=Y_train_micro, status=C_train_micro),ind.block.x=c(3,10,15),nt=2)) #> Kernel :  rbfdot  #> Estimated_sigma  0.01257168  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Kernel :  rbfdot  #> Estimated_sigma  0.01198263  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Kernel :  rbfdot  #> Estimated_sigma  0.01156809  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Kernel :  rbfdot  #> Estimated_sigma  0.01287851  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Kernel :  rbfdot  #> Estimated_sigma  0.01127231  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 2 #>  #> $cv.error10 #> [1] 0.5000000 0.6381540 0.6963262 #>  #> $cv.se10 #> [1] 0.00000000 0.03036225 0.02912723 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"function cross-validates coxDKsgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"","code":"cv.coxDKsgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"data list three items: x explanatory variables passed coxDKsgplsDR's Xplan argument, time passed coxDKsgplsDR's time argument, status coxDKsgplsDR's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxDKsgplsDR.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKsgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Direct Kernel group sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKsgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) if (FALSE) { # \\dontrun{ (cv.coxDKsgplsDR.res=cv.coxDKsgplsDR(list(x=X_train_micro, time=Y_train_micro,status=C_train_micro),ind.block.x=c(3,10,15),  alpha.x = rep(0.95, 6),nt=3)) } # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"function cross-validates coxDKspls_sgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"","code":"cv.coxDKspls_sgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"data list three items: x explanatory variables passed coxDKspls_sgplsDR's Xplan argument, time passed coxDKspls_sgplsDR's time argument, status coxDKspls_sgplsDR's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxDKspls_sgplsDR.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxDKspls_sgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Direct Kernel sparse PLS model fitted on the (Deviance) Residuals — cv.coxDKspls_sgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxDKspls_sgplsDR.res=cv.coxDKspls_sgplsDR(list(x=X_train_micro, time=Y_train_micro,status=C_train_micro),ind.block.x=c(3,10,15), alpha.x = rep(0.95, 3),nt=3)) #> Kernel :  rbfdot  #> Estimated_sigma  0.01257168  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Kernel :  rbfdot  #> Estimated_sigma  0.01198263  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Kernel :  rbfdot  #> Estimated_sigma  0.01156809  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Kernel :  rbfdot  #> Estimated_sigma  0.01287851  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Kernel :  rbfdot  #> Estimated_sigma  0.01127231  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.6530362 0.7257771 0.6553724 #>  #> $cv.se10 #> [1] 0.00000000 0.03313505 0.03135189 0.04381849 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"function cross-validates coxgpls models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"","code":"cv.coxgpls(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"data list three items: x explanatory variables passed coxgpls's Xplan argument, time passed coxgpls's time argument, status coxgpls's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxgpls.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on group PLSR components — cv.coxgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxgpls.res=cv.coxgpls(list(x=X_train_micro,time=Y_train_micro, status=C_train_micro),ind.block.x=c(3,10,15),nt=3)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.5225223 0.6037656 0.5639968 #>  #> $cv.se10 #> [1] 0.00000000 0.05032449 0.04012942 0.03493106 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"function cross-validates coxgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"","code":"cv.coxgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"data list three items: x explanatory variables passed coxgpls's Xplan argument, time passed coxgpls's time argument, status coxgpls's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxgpls.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on group PLSR components using (Deviance) Residuals — cv.coxgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxgplsDR.res=cv.coxgplsDR(list(x=X_train_micro,time=Y_train_micro, status=C_train_micro),ind.block.x=c(3,10,15),nt=3)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.6786893 0.6913293 0.6485690 #>  #> $cv.se10 #> [1] 0.00000000 0.04017423 0.02726346 0.03897730 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"function cross-validates coxsgpls models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"","code":"cv.coxsgpls(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"data list three items: x explanatory variables passed coxsgpls's Xplan argument, time passed coxsgpls's time argument, status coxsgpls's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxsgpls.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components — cv.coxsgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxsgpls.res=cv.coxsgpls(list(x=X_train_micro,time=Y_train_micro, status=C_train_micro),ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6),nt=3)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.4217599 0.5382923 0.5519544 #>  #> $cv.se10 #> [1] 0.00000000 0.03195833 0.02746499 0.03490158 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 3 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"function cross-validates coxsgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"","code":"cv.coxsgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"data list three items: x explanatory variables passed coxsgplsDR's Xplan argument, time passed coxsgplsDR's time argument, status coxsgplsDR's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxsgplsDR.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxsgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on sparse group PLSR components using (Deviance) Residuals — cv.coxsgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxsgplsDR.res=cv.coxsgplsDR(list(x=X_train_micro,time=Y_train_micro, status=C_train_micro),ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6),nt=2)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 2 #>  #> $cv.error10 #> [1] 0.5000000 0.6856847 0.6944862 #>  #> $cv.se10 #> [1] 0.00000000 0.03282521 0.03554813 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 2 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"function cross-validates coxspls_sgpls models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"","code":"cv.coxspls_sgpls(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"data list three items: x explanatory variables passed coxspls_sgpls's Xplan argument, time passed coxspls_sgpls's time argument, status coxspls_sgpls's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxspls_sgpls.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgpls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on sparse PLSR components — cv.coxspls_sgpls","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxspls_sgpls.res=cv.coxspls_sgpls(list(x=X_train_micro, time=Y_train_micro,status=C_train_micro),ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6),nt=3)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.4217599 0.5382923 0.5519544 #>  #> $cv.se10 #> [1] 0.00000000 0.03195833 0.02746499 0.03490158 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 3 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"function cross-validates coxspls_sgplsDR models.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"","code":"cv.coxspls_sgplsDR(   data,   method = c(\"efron\", \"breslow\"),   nfold = 5,   nt = 10,   plot.it = TRUE,   se = TRUE,   givefold,   scaleX = TRUE,   folddetails = FALSE,   allCVcrit = FALSE,   details = FALSE,   namedataset = \"data\",   save = FALSE,   verbose = TRUE,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"data list three items: x explanatory variables passed coxspls_sgplsDR's Xplan argument, time passed coxspls_sgplsDR's time argument, status coxspls_sgplsDR's status argument. method character string specifying method tie handling. tied death times methods equivalent. Efron approximation used default , accurate dealing tied death times, efficient computationally. nfold number folds use perform cross-validation process. nt number components include model. supplied, 10 components fitted. plot.Shall results displayed plot ? se standard errors plotted ? givefold Explicit list omited values fold can provided using argument. scaleX Shall predictors standardized ? folddetails values completion status folds returned ? allCVcrit 13 CV criteria evaled returned ? details results functions perform error computations returned ? namedataset Name use craft temporary results names save temporary results saved ? verbose CV details displayed ? ... arguments pass coxspls_sgplsDR.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"nt number components requested cv.error1 Vector mean values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.error2 Vector mean values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.error3 Vector mean values, across folds, iAUC_CD models 0 nt components. cv.error4 Vector mean values, across folds, iAUC_hc models 0 nt components. cv.error5 Vector mean values, across folds, iAUC_sh models 0 nt components. cv.error6 Vector mean values, across folds, iAUC_Uno models 0 nt components. cv.error7 Vector mean values, across folds, iAUC_hz.train models 0 nt components. cv.error8 Vector mean values, across folds, iAUC_hz.test models 0 nt components. cv.error9 Vector mean values, across folds, iAUC_survivalROC.train models 0 nt components. cv.error10 Vector mean values, across folds, iAUC_survivalROC.test models 0 nt components. cv.error11 Vector mean values, across folds, iBrierScore unw models 0 nt components. cv.error12 Vector mean values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.error13 Vector mean values, across folds, iBrierScore w models 0 nt components. cv.error14 Vector mean values, across folds, iSchmidScore (robust BS) w models 0 nt components. cv.se1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. cv.se2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. cv.se3 Vector standard error values, across folds, iAUC_CD models 0 nt components. cv.se4 Vector standard error values, across folds, iAUC_hc models 0 nt components. cv.se5 Vector standard error values, across folds, iAUC_sh models 0 nt components. cv.se6 Vector standard error values, across folds, iAUC_Uno models 0 nt components. cv.se7 Vector standard error values, across folds, iAUC_hz.train models 0 nt components. cv.se8 Vector standard error values, across folds, iAUC_hz.test models 0 nt components. cv.se9 Vector standard error values, across folds, iAUC_survivalROC.train models 0 nt components. cv.se10 Vector standard error values, across folds, iAUC_survivalROC.test models 0 nt components. cv.se11 Vector standard error values, across folds, iBrierScore unw models 0 nt components. cv.se12 Vector standard error values, across folds, iSchmidScore (robust BS) unw models 0 nt components. cv.se13 Vector standard error values, across folds, iBrierScore w models 0 nt components. cv.se14 Vector standard error values, across folds, iSchmidScore (robust BS) w models 0 nt components. folds Explicit list values omited values fold. lambda.min1 Vector standard error values, across folds, , per fold unit, Cross-validated log-partial-likelihood models 0 nt components. lambda.min2 Vector standard error values, across folds, , per fold unit, van Houwelingen Cross-validated log-partial-likelihood models 0 nt components. lambda.min1 Optimal Nbr components, min Cross-validated log-partial-likelihood criterion. lambda.se1 Optimal Nbr components, min+1se Cross-validated log-partial-likelihood criterion. lambda.min2 Optimal Nbr components, min van Houwelingen Cross-validated log-partial-likelihood. lambda.se2 Optimal Nbr components, min+1se van Houwelingen Cross-validated log-partial-likelihood. lambda.min3 Optimal Nbr components, max iAUC_CD criterion. lambda.se3 Optimal Nbr components, max+1se iAUC_CD criterion. lambda.min4 Optimal Nbr components, max iAUC_hc criterion. lambda.se4 Optimal Nbr components, max+1se iAUC_hc criterion. lambda.min5 Optimal Nbr components, max iAUC_sh criterion. lambda.se5 Optimal Nbr components, max+1se iAUC_sh criterion. lambda.min6 Optimal Nbr components, max iAUC_Uno criterion. lambda.se6 Optimal Nbr components, max+1se iAUC_Uno criterion. lambda.min7 Optimal Nbr components, max iAUC_hz.train criterion. lambda.se7 Optimal Nbr components, max+1se iAUC_hz.train criterion. lambda.min8 Optimal Nbr components, max iAUC_hz.test criterion. lambda.se8 Optimal Nbr components, max+1se iAUC_hz.test criterion. lambda.min9 Optimal Nbr components, max iAUC_survivalROC.train criterion. lambda.se9 Optimal Nbr components, max+1se iAUC_survivalROC.train criterion. lambda.min10 Optimal Nbr components, max iAUC_survivalROC.test criterion. lambda.se10 Optimal Nbr components, max+1se iAUC_survivalROC.test criterion. lambda.min11 Optimal Nbr components, min iBrierScore unw criterion. lambda.se11 Optimal Nbr components, min+1se iBrierScore unw criterion. lambda.min12 Optimal Nbr components, min iSchmidScore unw criterion. lambda.se12 Optimal Nbr components, min+1se iSchmidScore unw criterion. lambda.min13 Optimal Nbr components, min iBrierScore w criterion. lambda.se13 Optimal Nbr components, min+1se iBrierScore w criterion. lambda.min14 Optimal Nbr components, min iSchmidScore w criterion. lambda.se14 Optimal Nbr components, min+1se iSchmidScore w criterion. errormat1-14 details=TRUE, matrices error values every folds across components criteria completed.cv1-14 details=TRUE, matrices logical values every folds across components criteria: TRUE computation completed FALSE failed. All_indics results functions perform error computation, fold, component error criterion.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"computes recommended iAUCSurvROC criterion. Set allCVcrit=TRUE retrieve 13 ones.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660. Cross validating extensions kernel, sparse regular partial least squares regression models censored data, Bertrand, F., Bastien, Ph. Maumy-Bertrand, M. (2018), https://arxiv.org/abs/1810.01005.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/cv.coxspls_sgplsDR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validating a Cox-Model fitted on sparse PLSR components components using (Deviance) Residuals — cv.coxspls_sgplsDR","text":"","code":"data(micro.censure) data(Xmicro.censure_compl_imp) set.seed(123456) X_train_micro <- apply((as.matrix(Xmicro.censure_compl_imp)), FUN=\"as.numeric\",MARGIN=2)[1:80,] X_train_micro_df <- data.frame(X_train_micro) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80]  #Should be run with a higher value of nt (at least 10) (cv.coxspls_sgplsDR.res=cv.coxspls_sgplsDR(list(x=X_train_micro, time=Y_train_micro,status=C_train_micro),ind.block.x=c(3,10,15), alpha.x = rep(0.95, 6),nt=3)) #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 1  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 2  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 3  #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 4  #> Warning: no non-missing arguments to min; returning Inf #> CV Fold 5   #> $nt #> [1] 3 #>  #> $cv.error10 #> [1] 0.5000000 0.4217599 0.5382923 0.5519544 #>  #> $cv.se10 #> [1] 0.00000000 0.03195833 0.02746499 0.03490158 #>  #> $folds #> $folds$`1` #>  [1] 60  3  2 14 77  6 50  4 72 32 22  1 41 21 63 25 #>  #> $folds$`2` #>  [1] 42 67 65 15 73 48 57 26  7 13 31 53  5 27 37 64 #>  #> $folds$`3` #>  [1] 71 23 56 35 75 29 30 18 62 44 12 33 68 49 43 55 #>  #> $folds$`4` #>  [1] 54 76 24 16 34 66  9 11 69 40 70 36 39  8 19 20 #>  #> $folds$`5` #>  [1] 74 38 46 80 47 78 10 45 51 28 61 79 58 17 52 59 #>  #>  #> $lambda.min10 #> [1] 3 #>  #> $lambda.1se10 #> [1] 0 #>"},{"path":"https://fbertran.github.io/bigPLScox/reference/dCox_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated survival dataset for Cox models — dCox_sim","title":"Simulated survival dataset for Cox models — dCox_sim","text":"dCox_sim dataset contains simulated survival times, censoring indicators two binary covariates demonstrating Cox-related procedures included bigPLScox.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dCox_sim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated survival dataset for Cox models — dCox_sim","text":"data frame 10000 observations following 5 variables. id observation identifier time simulated survival time status event indicator (1 = event, 0 = censored) x.1 first binary covariate x.2 second binary covariate","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dCox_sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated survival dataset for Cox models — dCox_sim","text":"","code":"# \\donttest{ data(dCox_sim) with(dCox_sim, table(status)) #> status #>    0    1  #> 5612 4388  # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"Function dataCox generaters random survivaldata Weibull distribution (parameters lambda rho given input x data, model coefficients beta censoring rate censoring comes exponential distribution parameter cens.rate.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"","code":"dataCox(n, lambda, rho, x, beta, cens.rate)"},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"n Number observations generate. lambda lambda parameter Weibull distribution. rho rho parameter Weibull distribution. x data.frame input data generate survival times . beta True model coefficients. cens.rate Parameter exponential distribution, responsible censoring.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"data.frame containing columns: id integer. time survival times. status observation status (event occured (1) (0)). x data.frame input data generate survival times .","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"observation true survival time generated censroing time. censoring time less survival time, survival time returned status observations set 0 means observation censored time. survival time less censoring time, observation true survival time returned status observation set 1 means event noticed.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"http://onlinelibrary.wiley.com/doi/10.1002/sim.2059/abstract Generating survival times simulate Cox proportional hazards models, 2005 Ralf Bender, Thomas Augustin, Maria Blettner.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/dataCox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cox Proportional Hazards Model Data Generation From Weibull Distribution — dataCox","text":"","code":"if (FALSE) { # \\dontrun{ x <- matrix(sample(0:1, size = 20000, replace = TRUE), ncol = 2) dCox <- dataCox(10^4, lambda = 3, rho = 2, x, beta = c(1,3), cens.rate = 5)  } # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/internal-bigPLS.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal bigPLScox functions — internal-bigPLS","title":"Internal bigPLScox functions — internal-bigPLS","text":"called user.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/internal-bigPLS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Internal bigPLScox functions — internal-bigPLS","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/internal-bigPLS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal bigPLScox functions — internal-bigPLS","text":"Frédéric Bertrandfrederic.bertrand@lecnam.nethttps://fbertran.github.io/homepage/","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/micro.censure.html","id":null,"dir":"Reference","previous_headings":"","what":"Microsat features and survival times — micro.censure","title":"Microsat features and survival times — micro.censure","text":"dataset provides Microsat specifications survival times.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/micro.censure.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Microsat features and survival times — micro.censure","text":"data frame 117 observations following 43 variables. numpat factor levels B1006 B1017 B1028 B1031 B1046 B1059 B1068 B1071 B1102 B1115 B1124 B1139 B1157 B1161 B1164 B1188 B1190 B1192 B1203 B1211 B1221 B1225 B1226 B1227 B1237 B1251 B1258 B1266 B1271 B1282 B1284 B1285 B1286 B1287 B1290 B1292 B1298 B1302 B1304 B1310 B1319 B1327 B1353 B1357 B1363 B1368 B1372 B1373 B1379 B1388 B1392 B1397 B1403 B1418 B1421t1 B1421t2 B1448 B1451 B1455 B1460 B1462 B1466 B1469 B1493 B1500 B1502 B1519 B1523 B1529 B1530 B1544 B1548 B500 B532 B550 B558 B563 B582 B605 B609 B634 B652 B667 B679 B701 B722 B728 B731 B736 B739 B744 B766 B771 B777 B788 B800 B836 B838 B841 B848 B871 B873 B883 B889 B912 B924 B925 B927 B938 B952 B954 B955 B968 B972 B976 B982 B984 D18S61 numeric vector D17S794 numeric vector D13S173 numeric vector D20S107 numeric vector TP53 numeric vector D9S171 numeric vector D8S264 numeric vector D5S346 numeric vector D22S928 numeric vector D18S53 numeric vector D1S225 numeric vector D3S1282 numeric vector D15S127 numeric vector D1S305 numeric vector D1S207 numeric vector D2S138 numeric vector D16S422 numeric vector D9S179 numeric vector D10S191 numeric vector D4S394 numeric vector D1S197 numeric vector D6S264 numeric vector D14S65 numeric vector D17S790 numeric vector D5S430 numeric vector D3S1283 numeric vector D4S414 numeric vector D8S283 numeric vector D11S916 numeric vector D2S159 numeric vector D16S408 numeric vector D6S275 numeric vector D10S192 numeric vector sexe numeric vector Agediag numeric vector Siege numeric vector T numeric vector N numeric vector M numeric vector STADE factor levels 0 1 2 3 4 survyear numeric vector DC numeric vector","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/micro.censure.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Microsat features and survival times — micro.censure","text":"Allelotyping identification genomic alterations rectal chromosomally unstable tumors without preoperative treatment, #' Benoît Romain, Agnès Neuville, Nicolas Meyer, Cécile Brigand, Serge Rohr, Anne Schneider, Marie-Pierre Gaub Dominique Guenot, BMC Cancer 2010, 10:561, doi:10.1186/1471-2407-10-561.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/micro.censure.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Microsat features and survival times — micro.censure","text":"plsRcox, Cox-Models high dimensional setting R, Frederic Bertrand, Philippe Bastien, Nicolas Meyer Myriam Maumy-Bertrand (2014). Proceedings User2014!, Los Angeles, page 152. Deviance residuals-based sparse PLS sparse kernel PLS regression censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer Myriam Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404, doi:10.1093/bioinformatics/btu660.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/micro.censure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Microsat features and survival times — micro.censure","text":"","code":"# \\donttest{ data(micro.censure) Y_train_micro <- micro.censure$survyear[1:80] C_train_micro <- micro.censure$DC[1:80] Y_test_micro <- micro.censure$survyear[81:117] C_test_micro <- micro.censure$DC[81:117] rm(Y_train_micro,C_train_micro,Y_test_micro,C_test_micro) # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/partialbigSurvSGDv0.html","id":null,"dir":"Reference","previous_headings":"","what":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","title":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","text":"Loads previously scaled design matrix continues stochastic gradient optimisation subset variables.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/partialbigSurvSGDv0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","text":"","code":"partialbigSurvSGDv0(   name.col,   datapath,   ncores = 1,   resBigscale,   bigmemory.flag = FALSE,   parallel.flag = FALSE,   inf.mth = \"none\" )"},{"path":"https://fbertran.github.io/bigPLScox/reference/partialbigSurvSGDv0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","text":"name.col Character vector containing column names included partial fit. datapath File system path connection big-memory backing file scaled design matrix stored. ncores Number processor cores allocated partial fitting procedure. Defaults 1. resBigscale Result object returned bigscale containing scaling statistics reused. default helper reuses globally cached resultsBigscale object created bigscale. bigmemory.flag Logical flag determining whether big-memory backed matrices used loading updating design matrix. Defaults FALSE. parallel.flag Logical flag toggling use parallelised stochastic gradient updates. Defaults FALSE. inf.mth Inference method requested partial fit, \"none\", \"asymptotic\", bootstrap summaries. Defaults \"none\".","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/partialbigSurvSGDv0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","text":"Either numeric vector log hazard-ratio coefficients , inference requested, matrix whose columns correspond inferred coefficient summaries penalisation setting.","code":""},{"path":[]},{"path":"https://fbertran.github.io/bigPLScox/reference/partialbigSurvSGDv0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Incremental Survival Model Fitting with Pre-Scaled Data — partialbigSurvSGDv0","text":"","code":"if (FALSE) { # \\dontrun{ continued <- partialbigSurvSGDv0(   name.col = c(\"age\", \"sex\"),   datapath = tempfile(),   ncores = 2,   resBigscale = scaled,   bigmemory.flag = TRUE,   parallel.flag = TRUE,   inf.mth = \"bootstrap\" ) } # }"},{"path":"https://fbertran.github.io/bigPLScox/reference/pls_big.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial least squares for bigmemory matrices — pls_big","title":"Partial least squares for bigmemory matrices — pls_big","text":"`pls_big()` fits partial least squares (PLS) model using NIPALS algorithm implemented C++ operates directly [bigmemory::big.matrix] inputs. -memory file-backed matrices supported. `matrixpls_stream_bigmatrix()` pure R fallback performs computation streaming chunks file-backed `big.matrix` without loading fully memory.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/pls_big.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partial least squares for bigmemory matrices — pls_big","text":"","code":"pls_big(   X,   Y,   ncomp = 2L,   tol = 1e-06,   max_iter = 500L,   stream = FALSE,   num.rows.chunk = 1e+06,   backingfile = NULL,   backingpath = NULL,   descriptorfile = NULL,   type = \"double\",   ... )  matrixpls_stream_bigmatrix(   X,   Y,   ncomp = 2L,   tol = 1e-06,   max_iter = 500L,   num.rows.chunk = 1e+06,   ... )"},{"path":"https://fbertran.github.io/bigPLScox/reference/pls_big.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partial least squares for bigmemory matrices — pls_big","text":"X Either `bigmemory::big.matrix`, `bigmemory::big.matrix.descriptor`, character path delimited file can read [bigmemory::read.big.matrix()]. Y Numeric response matrix matching number rows. Vectors coerced one-column matrix. ncomp Number latent components extract. tol Convergence tolerance iterative updates. max_iter Maximum number iterations NIPALS inner loop. stream Logical; `TRUE`, force chunk-wise R implementation via [matrixpls_stream_bigmatrix()]. num.rows.chunk Number rows load per chunk `stream = TRUE`. backingfile, backingpath, descriptorfile Optional arguments passed [bigmemory::read.big.matrix()] `X` file path. type Storage mode use reading file path, defaulting `\"double\"`. ... Reserved future extensions.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/pls_big.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partial least squares for bigmemory matrices — pls_big","text":"list containing   * `scores`: X-score matrix (`T`)   * `Yscores`: Y-score matrix (`U`)   * `weights`: weight matrix (`W`)   * `loadings`: X-loading matrix (`P`)   * `Yloadings`: Y-loading matrix (`Q`)   * `coefficients`: regression coefficients linking `T` `U`","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated dataset — sim_data","title":"Simulated dataset — sim_data","text":"dataset provides explantory variables simulations censoring status.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/sim_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated dataset — sim_data","text":"data frame 1000 observations following 11 variables. status binary vector X1 numeric vector X2 numeric vector X3 numeric vector X4 numeric vector X5 numeric vector X6 numeric vector X7 numeric vector X8 numeric vector X9 numeric vector X10 numeric vector","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/sim_data.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated dataset — sim_data","text":"TODO.","code":""},{"path":"https://fbertran.github.io/bigPLScox/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated dataset — sim_data","text":"","code":"# \\donttest{ data(sim_data) X_sim_data_train <- sim_data[1:800,2:11] C_sim_data_train <- sim_data$status[1:800] X_sim_data_test <- sim_data[801:1000,2:11] C_sim_data_test <- sim_data$status[801:1000] rm(X_sim_data_train,C_sim_data_train,X_sim_data_test,C_sim_data_test) # }"},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-050","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.5.0","title":"bigPLScox 0.5.0","text":"Added reproducible benchmarking utilities inst/benchmarks comparing big_pls_cox() plsRcox::plsRcox() -memory file-backed matrices. Published two package vignettes cover introductory workflows large-scale analyses bigmemory. Added introductory vignette covering core Cox-PLS workflow. Refreshed README website copy highlight core functionality demonstrate working examples without warnings. Refreshed README guidance learning materials benchmarking. Completed package-level documentation bibliographic references. Updated package metadata list optional dependencies used docs benchmarks.","code":""},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-040","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.4.0","title":"bigPLScox 0.4.0","text":"Updated maintainer contact details DESCRIPTION. Added unit tests big_pls_cox() big_pls_cox_gd() stability checks. Added unit tests covering new C++-accelerated Cox PLS implementation cross-validation utilities.","code":""},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-030","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.3.0","title":"bigPLScox 0.3.0","text":"Improved big_pls_cox() numerical stability added support additional convergence diagnostics gradient-descent solver. Refactored stochastic gradient solvers better integrate bigmemory file-backed matrices. Improved numerical stability deviance residual computations.","code":""},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-020","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.2.0","title":"bigPLScox 0.2.0","text":"Expanded documentation examples deviance residuals Cox model utilities. Added dataset documentation micro.censure simulated Cox examples. Added pkgdown site configuration continuous integration workflows.","code":""},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-010","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.1.0","title":"bigPLScox 0.1.0","text":"Introduced gPLS sgPLS model families support grouped predictors deviance residual pipelines cross-validation support.","code":""},{"path":"https://fbertran.github.io/bigPLScox/news/index.html","id":"bigplscox-001","dir":"Changelog","previous_headings":"","what":"bigPLScox 0.0.1","title":"bigPLScox 0.0.1","text":"Initial package skeleton core data objects helper routines.","code":""}]
