---
title: "Benchmarking bigPLScox"
shorttitle: "Benchmarking bigPLScox"
author:
- name: "Frédéric Bertrand"
  affiliation: 
  - Cedric, Cnam, Paris
  email: frederic.bertrand@lecnam.net
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
  toc: true
vignette: >
  %\VignetteIndexEntry{Benchmarking bigPLScox}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/benchmark-",
  out.width = "100%"
)
```

# Motivation

High-dimensional survival datasets can be computationally demanding. **bigPLScox**
implements algorithms that scale to large numbers of predictors and observations via
component-based models, sparse penalties, and stochastic gradient descent routines.
This vignette demonstrates how to benchmark the package against baseline approaches.

We recommend using the **bench** package for reproducible comparisons.

# Setup

```{r message=FALSE}
library(bigPLScox)
library(survival)
library(bench)
```

The benchmarking dataset is simulated through the `dataCox()` helper. We work with a
moderately sized problem here, but larger values for `n` and `p` can be used to stress
test performance.

```{r}
set.seed(2024)
sim_design <- dataCox(
  n = 2000,
  lambda = 2,
  rho = 1.5,
  x = matrix(rnorm(2000 * 50), ncol = 50),
  beta = c(1, 3, rep(0, 48)),
  cens.rate = 5
)
```

We then compare `coxgpls()` to the Cox model available in **survival**.

```{r}
cox_data <- list(
  x = as.matrix(sim_design[,-(1:3)]),
  time = sim_design$time,
  status = sim_design$status
)
```

# Running the benchmark

```{r}
res <- bench::mark(
  bigPLScox = coxgpls(
    cox_data$x,
    cox_data$time,
    cox_data$status,
    ncomp = 5,
    ind.block.x = c(3, 10)
  ),
  survival = coxph(Surv(cox_data$time, cox_data$status) ~ cox_data$x, ties = "breslow"),
  iterations = 100,
  check = FALSE
)
res
```

The resulting tibble reports elapsed time, memory allocations, and garbage collection
statistics for each estimator.

# Visualising the results

```{r}
plot(res, type = "jitter")
```

The plot highlights the trade-off between runtime and memory usage. In many cases,
`coxgpls()` provides a favourable compromise thanks to the lower latent dimensionality
introduced by the PLS components.

# Exporting benchmark results

Use the function `write.csv(res, file = "benchmarks/bigPLScox-benchmark.csv")` to store
results as part of a reproducible pipeline. For large-scale studies, you can wrap the
benchmark in custom loops that vary the number of components, sparsity constraints, or
data size.
